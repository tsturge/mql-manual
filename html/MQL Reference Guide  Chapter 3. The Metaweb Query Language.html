
<!-- saved from url=(0032)http://mql.freebaseapps.com/ch03 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>
        MQL Reference Guide: 
  Chapter 3. The Metaweb Query Language
      </title>
      <link href="./MQL Reference Guide  Chapter 3. The Metaweb Query Language_files/stylesheet.css" rel="stylesheet" type="text/css">
              
  
  <link href="http://mql.freebaseapps.com/index" rel="home" title="Table of Contents">
  <link href="http://mql.freebaseapps.com/index" rel="up" title="Table of Contents">
  <link href="http://mql.freebaseapps.com/ch02" rel="prev" title="Chapter 2. Metaweb Architecture">
  <link href="http://mql.freebaseapps.com/ch04" rel="next" title="Chapter 4. Metaweb Read Services">
    </head>
    <body>
      
  <div id="header">
    <div id="nav">
      Chapter 3. The Metaweb Query Language        
      
      <a href="http://mql.freebaseapps.com/ch02">◁ previous</a> 
      <a href="http://mql.freebaseapps.com/index">△ contents</a> 
      <a href="http://mql.freebaseapps.com/ch04">next ▷</a>
    </div>
    
    <div id="logo">
      <a href="http://mql.freebaseapps.com/index" title="MQL Reference Guide contents"><img alt="MQL Reference Guide" border="0" height="18" width="258" src="./MQL Reference Guide  Chapter 3. The Metaweb Query Language_files/logo-mqlreference.png"></a>
    </div>
  </div>
      
    <div class="chapter" lang="en" xml:lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title">
              <a id="mql" name="mql"></a>Chapter 3. The Metaweb Query Language
            </h2>
          </div>
        </div>
      </div>
      <p>
        This chapter explains the Metaweb Query Language, or MQL, <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2948012" id="id2948012" name="id2948012">7</a>]</sup> which is used to express Metaweb queries. This chapter begins with an explanation of the JSON data format, on which the MQL grammar is based. That prerequisite material is followed by an extended tutorial that teaches MQL by example. You are expected and encouraged to run queries and to experiment with your own queries, using a "query editor" program like the one at <span class="emphasis"><em><a class="ulink" href="http://www.freebase.com/tools/queryeditor">http://www.freebase.com/tools/queryeditor</a></em></span> to submit your queries to Metaweb and obtain the results.
      </p>
      <p>
        This chapter teaches you to write MQL queries, but does not explain how to issue those queries to and retrieve responses from Metaweb servers: that is the topic of <a class="xref" href="http://mql.freebaseapps.com/ch04.html" title="Chapter 4. Metaweb Read Services">Chapter 4</a>. Also, this chapter does not cover updates, or writes, to Metaweb. Updates are expressed using a variant of MQL that is covered in <a class="xref" href="http://mql.freebaseapps.com/ch05.html" title="Chapter 5. The MQL Write Grammar">Chapter 5</a>.
      </p>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title">
                <a id="json" name="json"></a>3.1. JavaScript Object Notation
              </h2>
            </div>
          </div>
        </div>
        <p>
          The Metaweb queries and responses we saw in <a class="xref" href="http://mql.freebaseapps.com/ch01.html" title="Chapter 1. Introduction">Chapter 1</a> contained a lot of punctuation: curly braces, quotation marks, colons, and commas. Before we study more queries, it is important to understand this punctuation. Metaweb queries and responses use a plain-text data interchange format known as <span class="emphasis"><em>JavaScript Object Notation</em></span> or, more commonly, JSON. If you are a JavaScript programmer, then this format will be familiar to you since it is a subset of the JavaScript language. <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2948079" id="id2948079" name="id2948079">8</a>]</sup> If you are not a JavaScript programmer, the format is easy-to-learn, and does not require the use of the JavaScript language.
        </p>
        <p>
          JSON is formally described in RFC 4627 (<span class="emphasis"><em>http://www.ietf.org/rfc/rfc4627.txt</em></span>), and is also documented at <span class="emphasis"><em>http://json.org</em></span>. The JSON website includes pointers to code, in a variety of programming languages, for serializing data structures into JSON format and for parsing JSON text into data structures. <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2948108" id="id2948108" name="id2948108">9</a>]</sup>
        </p>
        <p>
          A JSON-formatted string is a serialized form of an array or object. The array or object may contain numbers, strings, other arrays and objects, and the literal values <code class="literal">null</code>, <code class="literal">true</code>, and <code class="literal">false</code>. These JSON values are illustrated in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#jsonvalues" title="Figure 3.1. JSON Values">Figure 3.1</a> and explained in the sub-sections that follow:
        </p>
        <div class="figure">
          <a id="jsonvalues" name="jsonvalues"></a>
          <p class="title">
            <b>Figure 3.1. JSON Values</b>
          </p>
          <div class="figure-contents">
            <div>
              <img alt="JSON Values" src="./MQL Reference Guide  Chapter 3. The Metaweb Query Language_files/jsonvalue.gif">
            </div>
          </div>
        </div><br class="figure-break">
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="jsonliterals" name="jsonliterals"></a>3.1.1. JSON Literals: null, true, false
                </h3>
              </div>
            </div>
          </div>
          <p>
            JSON supports three literal values. <code class="literal">null</code> is a JSON value representing "no value". The literals <code class="literal">true</code> and <code class="literal">false</code> a represent the two possible Boolean values.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="jsonnumbers" name="jsonnumbers"></a>3.1.2. JSON Numbers
                </h3>
              </div>
            </div>
          </div>
          <p>
            A JSON number consists of an optional minus sign followed by an integer part followed by an optional decimal point and fractional part followed by an optional exponent. This format is the same as the format described for <code class="literal">/type/float</code> in <a class="xref" href="http://mql.freebaseapps.com/ch02.html" title="Chapter 2. Metaweb Architecture">Chapter 2</a>. All numbers use decimal digits: octal and hexadecimal notation are not supported.
          </p>
        </div>
        <div class="figure">
          <a id="jsonstring" name="jsonstring"></a>
          <p class="title">
            <b>Figure 3.2. JSON string syntax</b>
          </p>
          <div class="figure-contents">
            <div>
              <img alt="JSON string syntax" src="./MQL Reference Guide  Chapter 3. The Metaweb Query Language_files/jsonstring.gif">
            </div>
          </div>
        </div><br class="figure-break">
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="jsonstrings" name="jsonstrings"></a>3.1.3. JSON Strings
                </h3>
              </div>
            </div>
          </div>
          <p>
            A JSON string is much like a string in Java or JavaScript: zero or more Unicode characters <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2948241" id="id2948241" name="id2948241">10</a>]</sup> between double quotation marks. See <a class="xref" href="http://mql.freebaseapps.com/ch03.html#jsonstring" title="Figure 3.2. JSON string syntax">Figure 3.2</a>.
          </p>
          <p>
            A backslash is special: it is an escape character and is interpreted along with the character or characters that follow:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Escape
                  </th>
                  <th>
                    Character
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <code class="literal">\"</code>
                  </td>
                  <td>
                    <p>
                      A quotation mark that does not terminate the string
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\\</code>
                  </td>
                  <td>
                    <p>
                      A single backslash character that is not an escape
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\/</code>
                  </td>
                  <td>
                    <p>
                      A forward slash character. Although it is legal to escape the forward slash character, it is never necessary to do so.
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\b</code>
                  </td>
                  <td>
                    <p>
                      The Backspace character
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\f</code>
                  </td>
                  <td>
                    <p>
                      The Formfeed character
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\n</code>
                  </td>
                  <td>
                    <p>
                      The Newline character
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\r</code>
                  </td>
                  <td>
                    <p>
                      The Carriage Return character
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\t</code>
                  </td>
                  <td>
                    <p>
                      The Tab character
                    </p>
                  </td>
                </tr>
                <tr>
                  <td>
                    <code class="literal">\u</code><em class="replaceable"><code>XXXX</code></em>
                  </td>
                  <td>
                    <p>
                      The Unicode character whose encoding is the four hexadecimal digits <em class="replaceable"><code>XXXX</code></em>. To encode extended Unicode codepoints that do not fit in four hex digits, use two <code class="literal">\u</code> escapes to encode a UTF-16 surrogate pair.
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="jsonarrays" name="jsonarrays"></a>3.1.4. JSON Arrays
                </h3>
              </div>
            </div>
          </div>
          <p>
            An array is a comma-separated list of JSON values enclosed in square brackets. See <a class="xref" href="http://mql.freebaseapps.com/ch03.html#jsonarray" title="Figure 3.3. JSON array syntax">Figure 3.3</a>
          </p>
          <p>
            Arrays may contain any JSON values, including objects and other arrays. The elements of a JSON array need not have the same type (though in MQL they always do). The following JSON array might be returned in response to a MQL query:
          </p>
          <pre class="programlisting">["Outlandos d'Amour", "Reggatta de Blanc", "Zenyatta Mondatta"]
</pre>
          <div class="figure">
            <a id="jsonarray" name="jsonarray"></a>
            <p class="title">
              <b>Figure 3.3. JSON array syntax</b>
            </p>
            <div class="figure-contents">
              <div>
                <img alt="JSON array syntax" src="./MQL Reference Guide  Chapter 3. The Metaweb Query Language_files/jsonarray.gif">
              </div>
            </div>
          </div><br class="figure-break">
          <p>
            A JSON array with no elements consists of just the square brackets: <code class="literal">[]</code>. Empty arrays often appear in MQL queries.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="jsonobjects" name="jsonobjects"></a>3.1.5. JSON Objects
                </h3>
              </div>
            </div>
          </div>
          <p>
            A JSON object is named after the JavaScript object type, and is not very much like the objects of strongly-typed object-oriented programming languages. Instead, think of an object as:
          </p>
          <div class="itemizedlist">
            <ul>
              <li>
                <p>
                  an associative array;
                </p>
              </li>
              <li>
                <p>
                  a hashtable that maps strings to values;
                </p>
              </li>
              <li>
                <p>
                  a dictionary; or
                </p>
              </li>
              <li>
                <p>
                  an unordered set of named values.
                </p>
              </li>
            </ul>
          </div>
          <p>
            JSON objects are written as a comma-separated list of name/value pairs, enclosed in curly braces. A name/value pair is a JSON string (the name) followed by a colon followed by any JSON value, which may include nested objects and arrays. See <a class="xref" href="http://mql.freebaseapps.com/ch03.html#jsonobject" title="Figure 3.4. JSON object syntax">Figure 3.4</a>
          </p>
          <div class="figure">
            <a id="jsonobject" name="jsonobject"></a>
            <p class="title">
              <b>Figure 3.4. JSON object syntax</b>
            </p>
            <div class="figure-contents">
              <div>
                <img alt="JSON object syntax" src="./MQL Reference Guide  Chapter 3. The Metaweb Query Language_files/jsonobject.gif">
              </div>
            </div>
          </div><br class="figure-break">
          <p>
            Here is an example JSON object (which also happens to be a Metaweb query):
          </p>
          <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : []
}
</pre>
          <p>
            JavaScript programmers should note that JSON requires property names to appear within double quotes, even though the JavaScript language does not. Arbitrary whitespace is allowed within JSON objects and arrays, but trailing commas (after the final array element or last name/value pair) are not. An empty JSON object, with no properties at all is simply a pair of curly braces: <code class="literal">{}</code>. As we'll see, empty objects are not uncommon in MQL queries.
          </p>
        </div>
      </div>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title">
                <a id="mqltutorial" name="mqltutorial"></a>3.2. Basic MQL Queries
              </h2>
            </div>
          </div>
        </div>
        <p>
          This section is a tutorial that teaches basic Metaweb queries by example, and uses <span class="emphasis"><em>freebase.com</em></span> as a source of interesting data to query. Try to follow along as you read it by trying out the queries presented. To do this, you need a simple way to submit a query to <span class="emphasis"><em>freebase.com</em></span> and view the result. You can do this with the Freebase query editor at <span class="emphasis"><em>http://www.freebase.com/tools/queryeditor/</em></span>.
        </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="firstquery" name="firstquery"></a>3.2.1. Our First Query
                </h3>
              </div>
            </div>
          </div>
          <p>
            Let's begin by revisiting the simple query from <a class="xref" href="http://mql.freebaseapps.com/ch01.html" title="Chapter 1. Introduction">Chapter 1</a>. We would like to know what albums The Police have recorded:
          </p>
          <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : []
}
</pre>
          <p>
            When we run this query, we get the following JSON object in response (some of the album names are omitted here for brevity):
          </p>
          <pre class="programlisting">{
  "type": "/music/artist",
  "name": "The Police",
  "album": [
    "Outlandos d'Amour",
    "Reggatta de Blanc",
    "Zenyatta Mondatta",
    "Ghost in the Machine",
    "Synchronicity",
  ]
}
</pre>
          <p>
            To query Metaweb we tell it what we already know by specifying properties and their values:
          </p>
          <pre class="programlisting">    "type" : "/music/artist",
    "name" : "The Police",
</pre>
          <p>
            And then we tell it what we want to know by specifying properties without values:
          </p>
          <pre class="programlisting">    "album" : []
</pre>
          <p>
            Sending an empty array in a MQL query tells Metaweb that we'd like to have the array filled in.
          </p>
          <div class="sidebar">
            <p class="title">
              <b>Singular or Plural?</b>
            </p>
            <p>
              Note that the property we query in the example above is named "album" and not "albums", even though bands like The Police may well have more than one album. This reflects the underlying nature of Metaweb: the database object that represents The Police has many links of type "album" that refer to the objects that represent those albums. The type <code class="literal">/music/artist</code> aggregates these many links into a single set of albums, but retains the singular name "album" because that is the name of the underlying link type.
            </p>
            <p>
              Also, as we'll see soon when you want to obtain information (such as a list of tracks) about one particular album, you specify a single value (instead of an array) for the <code class="literal">album</code> property. In this case, the singular name makes a lot of sense.
            </p>
            <p>
              Although property names are typically singular, there are exceptions to this rule, and sometimes you'll see a plural property name.
            </p>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="responsesymmetry" name="responsesymmetry"></a>3.2.2. Query/Response Symmetry
                </h3>
              </div>
            </div>
          </div>
          <p>
            Let's look one more time at the simple "albums by The Police" query and response from above. This time the query and response are presented side-by-side to emphasize that the query and response objects have the same properties, but the response object has values filled in:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : []
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type": "/music/artist",
  "name": "The Police",
  "album": [
    "Outlandos d'Amour",
    "Reggatta de Blanc",
    "Zenyatta Mondatta",
    "Ghost in the Machine",
    "Synchronicity"
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This symmetry of queries and responses is a fundamental and elegant part of MQL. We'll use this two-column query/response format throughout the chapter.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="mqlids" name="mqlids"></a>3.2.3. Object IDs
                </h3>
              </div>
            </div>
          </div>
          <p>
            Objects can be given fully-qualified names that can be used as unique identifiers. Query the <code class="literal">id</code> property of an object to obtain a unique identifier for it:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "id" : null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type": "/music/artist",
  "name": "The Police",
  "id": "/en/the_police"
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query includes the same name and type as the last query. But instead of specifying an empty array of albums, it specifies a <code class="literal">null</code> id. The <code class="literal">null</code> value is our query: this is the field we want Metaweb to fill in. The response looks just like the query, but the null has been replaced with a unique fully-qualified name for The Police.
          </p>
          <p>
            In addition to querying the <code class="literal">id</code> property of an object, we can also use it to uniquely name the object we want. We could rewrite our musical albums query to use <code class="literal">id</code> instead of <code class="literal">name</code>, for example:
          </p>
          <pre class="programlisting">{
  "type": "/music/artist",
  "id": "/en/the_police",
  "album": []
}
</pre>
          <p>
            Metaweb objects are not required to have a fully-qualified name, but every object is assigned a string of hexadecimal digits that serves as a globally unique identifier or <span class="emphasis"><em>guid</em></span>. If you query the <code class="literal">id</code> property of an object that does not have a fully-qualified name, Metaweb creates a synthetic identifier by prefixing the object's guid with <code class="literal">/guid/</code>:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "artist": "The Police",
  "name" : "Synchronicity",
  "id" : null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type": "/music/album",
  "artist": "The Police",
  "name": "Synchronicity",
  "id": "/guid/9202a8c04000641f8000000002f9e349"
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            You can use guid-based identifiers as the value of the <code class="literal">id</code> property to uniquely identify an object.
          </p>
          <div class="sidebar">
            <p class="title">
              <b>Freebase GUIDs in this Tutorial</b>
            </p>
            <p>
              The guids shown in the online HTML-formatted version of this tutorial are valid <span class="emphasis"><em>freebase.com</em></span> guids, and should remain valid in perpetuity. In hardcopy and PDF versions of the tutorial, guids have been shortened to allow queries and responses to fit side-by-side in the two-column format shown above. To use these printed guids online, restore them to validity by inserting <code class="literal">9202a8c0400064</code> at the start.
            </p>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="uniqueerror" name="uniqueerror"></a>3.2.4. Multiple Results and Uniqueness Errors
                </h3>
              </div>
            </div>
          </div>
          <p>
            Now that we know the id of the object representing The Police, let's turn our query around and ask about name and type of the object with that id:
          </p>
          <pre class="programlisting">{
  "id": "/en/the_police",
  "name" : null,
  "type" : null
}
</pre>
          <p>
            We're telling Metaweb what we have (the id) and asking for the values (name and type) that we don't have. When we submit this query, though, it doesn't work. The response envelope looks like this:
          </p>
          <pre class="programlisting">{
  "status": "200 OK",
  "code": "/api/status/ok",
  "qname": {
    "code": "/api/status/error",
    "messages": [
      {
        "code": "/api/status/error/mql/result",
        "message": "Unique query may have at most one result. Got 4",
        "info": {
          "count": 4,
          "result": [
            "/music/artist",
            "/common/topic",
            "/music/producer",
            "/music/musical_group"
          ]
        },
        "query": [
          {
            "error_inside": "type",
            "type": null,
            "id": "/en/the_police",
            "name": null
          }
        ],
        "path": "type"
      }
    ]
  }
}
</pre>
          <p>
            This response includes three properties named <code class="literal">code</code>. The outermost one indicates that the query was well-formed and could be processed. The middle <code class="literal">code</code> property is specific to our query (which we gave the name <code class="literal">qname</code>) and specifies that an error occurred. The <code class="literal">messages[0]</code> object provides details, including a more specific error code in the innermost <code class="literal">code</code> property. The <code class="literal">message</code> property of the message object is a human-readable version of this error code, and the <code class="literal">info</code> property provides further details about the error. The <code class="literal">query</code> property repeats the query that caused the error, and both the <code class="literal">query.error_inside</code> and the <code class="literal">path</code> properties indicate which part of the query caused the problem.
          </p>
          <p>
            What we learn from this response is that Metaweb could not respond to our query because we asked for a single type and it found four types. Let's try the query again. Now we're requesting a single name and an array of types for this uniquely specified object. This query works:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id": "/en/the_police",
  "name" : null,
  "type" : []
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id": "/en/the_police",
  "name": "The Police",
  "type": [
    "/music/artist",
    "/common/topic",
    "/music/producer",
    "/music/musical_group"
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The Metaweb object we asked about has the name "The Police" and it is a member of four types including <code class="literal">/common/topic</code> and <code class="literal">/music/artist</code>. Recall from <a class="xref" href="http://mql.freebaseapps.com/ch02.html" title="Chapter 2. Metaweb Architecture">Chapter 2</a> that <code class="literal">/common/topic</code> is a very generic type. Just about every Metaweb object that represents something an end user would have an interest in is a member of this type. The lesson to draw here is that objects almost always have more than one type, and any queries on the <code class="literal">type</code> property should use arrays. In general, it is always safe to use <code class="literal">[]</code> in place of <code class="literal">null</code> in your queries. If there is only one result the array returned in the response will simply have a single element. When you know that there can only be one result, however, it is usually more convenient and efficient to use <code class="literal">null</code>.
          </p>
          <div class="sidebar">
            <p class="title">
              <b>Single Values and Sets of Values</b>
            </p>
            <p>
              There is a fundamental asymmetry to MQL: when we query the type of an object, we get an array of types. But when we look up an object by type, we specify only one type. Metaweb objects have a set of types, not one single type. So when we specify the type of an object in a MQL query, all we are saying is that the object has at least one "type" link with that value. Thus, writing <code class="literal">"type":"/music/artist"</code> in a query does not say "the type <span class="emphasis"><em>is</em></span> /music/artist", but "the set of types <span class="emphasis"><em>includes</em></span> /music/artist". Put another way, we can say that a query provides constraints, and that the response provides values for the unconstrained properties of the query.
            </p>
          </div>
          <p>
            Uniqueness errors are a common pitfall for developers crafting Metaweb queries. Recall that <code class="literal">/type/property</code> allows certain properties to be specified as unique. The <code class="literal">id</code> and <code class="literal">name</code> properties are unique and can always be queried without square brackets. As we've seen, however, the <code class="literal">type</code> property is not unique: objects can (and many objects do) have more than one type. If a property is not guaranteed to be unique, then you should always use square brackets when querying its value.
          </p>
          <p>
            Although objects can have more than one fully-qualified name, queries of the <code class="literal">id</code> property never return more than one of these names. The <code class="literal">id</code> property is unique in another, more important, way: no two objects ever share the same id. Therefore, if a query includes an <code class="literal">id</code>, you can be confident that no more than one object will match. Therefore, a query like this one is correct:
          </p>
          <pre class="programlisting">{
  "id": "/en/the_police",
  "name" : null,
  "type" : []
}
</pre>
          <p>
            The <code class="literal">name</code> property is unique, <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2949293" id="id2949293" name="id2949293">11</a>]</sup> so it is always safe to query <code class="literal">name</code> with <code class="literal">null</code>, as we do above, rather than <code class="literal">[]</code>. On the other hand, the query that we started this tutorial with is risky:
          </p>
          <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : []
}
</pre>
          <p>
            This query worked for us: Freebase only knows about one musical artist named "The Police". Note, however, that there is no guarantee that this will always be the case. There is nothing to prevent someone from adding another band named "The Police" to <span class="emphasis"><em>freebase.com</em></span>. If such an addition were made, our query would suddenly fail.
          </p>
          <p>
            Depending on the design of your application, a uniqueness failure in this situation might actually be exactly what you want. If you get two results when you expected one, then perhaps the right thing to do is fail and display an error message to the user. In practice, however, most MQL programmers simply get in the habit of enclosing all queries in square brackets:
          </p>
          <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : []
}]
</pre>
          <p>
            When you write queries like this, you must be prepared to handle zero, one, or multiple results.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="nestedqueries" name="nestedqueries"></a>3.2.5. Nested Sub-queries
                </h3>
              </div>
            </div>
          </div>
          <p>
            Let's find out more about our favorite band. What are the names of the tracks on the album <span class="emphasis"><em>Synchronicity</em></span>?
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : {
    "name" : "Synchronicity",
    "track" : []
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type": "/music/artist",
  "name": "The Police",
  "album": {
    "name": "Synchronicity",
    "track": [
      "Synchronicity II",
      "Every Breath You Take",
      "King of Pain",
      "Wrapped Around Your Finger",
      "Tea in the Sahara",
      "Walking in Your Footsteps",
      "Miss Gradenko",
      "Murder by Numbers",
      "O My God",
      "Synchronicity I",
      "Mother"
    ]
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The interesting thing about this query is that it includes a sub-query nested inside curly braces. We're asking for an array of tracks from an album named "Synchronicity" recorded by a band named "The Police".
          </p>
          <p>
            Now consider the following query which includes a sub-query within a sub-query. It asks: "what artists have recorded the song <span class="emphasis"><em>Too Much Information</em></span>? How long is the song and what album does it appear on?". Some of the results have been omitted here.
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album": [{
    "name":null,
    "track": [{
      "name":"Too Much Information",
      "length": null
    }]
  }]
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : [{
    "name" : "Ghost in the Machine",
    "track" : [{
      "name" : "Too Much Information",
      "length" : 222.733
    }]
  },{
    "name" : "Message in a Box (disc 3)",
    "track" : [{
      "name" : "Too Much Information",
      "length" : 222.733
    }]
  }]
},{
  "type" : "/music/artist",
  "name" : "Duran Duran",
  "album" : [{
    "name" : "Duran Duran",
    "track" : [{
      "name" : "Too Much Information",
      "length" : 296.573
    }]
  }]
},{
  "type" : "/music/artist",
  "name" : "Quiet Riot",
  "album" : [{
    "name" : "Alive and Well",
    "track" : [{
      "name" : "Too Much Information",
      "length" : 268
    }]
  }]
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Let's take a closer look at this query. It involves three different objects: an artist, an album, and a track. We can't tell Metaweb anything interesting about the album (such as a name or id): just that it contains the song we're interested in. We can't tell Metaweb anything about the artist object either: just that they recorded an album that includes the song. Despite the seeming vagueness of this query, Metaweb has no trouble finding the answer we want.
          </p>
          <p>
            At first glance, it seems as if the only information we're providing to Metaweb with this query is the track name. But the structure of the query contains additional implicit information. We've specified that the outermost object is a <code class="literal">/music/artist</code>. The definition of this type tells us that objects connected via the <code class="literal">album</code> property are expected to be of type <code class="literal">/music/album</code>. And the definition of the <code class="literal">/music/album</code> type tells us that objects connected through the <code class="literal">track</code> property should be of type <code class="literal">/music/track</code>. These additional constraints give Metaweb enough information to find the information we want.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2949556" name="id2949556"></a>3.2.6. Inverting Queries
                </h3>
              </div>
            </div>
          </div>
          <p>
            With MQL, there is usually more than one way to write a query. This is especially true when a query contains sub-queries – because of the bi-directional nature of Metaweb links, queries can usually be turned "inside out". At the beginning of the last section we wrote a query to ask for the names of tracks on the album Synchronicity. That was an artist-centric query with <code class="literal">"type":"/music/artist"</code> in the outermost query. We can invert the query and get the same information with a track-centric query:
          </p>
          <pre class="programlisting">[{
  "type":"/music/track",
  "name":null,
  "album":{
    "name":"Synchronicity",
    "artist":"The Police"
  }
}]
</pre>
          <p>
            This query returns the same list of track names, but the results are much more verbose, since every track object includes a nested. In this case, the simplest way to obtain the list of tracks we want is probably with a non-nested album-centric query:
          </p>
          <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : []
}
</pre>
          <p>
            The previous section included another artist-centric query to asked about recordings of the song "Too Much Information". Here's the album-centric version of that query:
          </p>
          <pre class="programlisting">[{
  "type":"/music/album",
  "name":null,
  "artist":null,
  "track": [{
    "name":"Too Much Information",
    "length": null
  }]
}]
</pre>
          <p>
            We can also invert this query into a track-centric form, of course:
          </p>
          <pre class="programlisting">[{
  "type":"/music/track",
  "name":"Too Much Information",
  "length":null,
  "album":[{"name":null, "artist":null}]
}]
</pre>
          <p>
            The track, album, and artist-centric versions of this query all return the same basic information. Which version is best depends on how you intend to use the results. Often this will be a question of which result format most closely matches the data structures used by the application that is making the query.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="returnobjects" name="returnobjects"></a>3.2.7. Asking Metaweb For Objects
                </h3>
              </div>
            </div>
          </div>
          <p>
            In our queries so far, we've used <code class="literal">null</code> and <code class="literal">[]</code> to ask Metaweb to fill in a single value or an array of values. There are other ways to ask for information as well. Recall the following query:
          </p>
          <pre class="programlisting">{
  "id" : "/en/the_police",
  "name" : null,
  "type" : []
}
</pre>
          <p>
            It asks for the name and types of a unique object. Both the name, and the individual elements of the <code class="literal">type</code> array are returned as strings. Recall, however, that the name of an object is of <code class="literal">/type/text</code> and that types are of <code class="literal">/type/type</code>. <code class="literal">/type/text</code> is a value type in the Metaweb object model, but we can treat values as objects if we want to. Let's modify the query to use <code class="literal">{}</code> and <code class="literal">[{}]</code> instead of <code class="literal">null</code> and <code class="literal">[]</code>. <code class="literal">{}</code> asks for a single value, expanded as an object, and <code class="literal">[{}]</code> asks for an array of values expanded into objects:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id": "/en/the_police",
  "name" : {},
  "type" : [{}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "name" : {
    "lang" : "/lang/en",
    "type" : "/type/text",
    "value" : "The Police"
  },
  "type" : [{
    "id" : "/music/artist",
    "name" : "Musical Artist",
    "type" : ["/type/type","/freebase/type_profile"]
  },{
    "id" : "/common/topic",
    "name" : "Topic",
    "type" : ["/type/type","/freebase/type_profile"]
  },{
    "id" : "/music/producer",
    "name" : "Record Producer",
    "type" : ["/type/type","/freebase/type_profile"]
  },{
    "id" : "/music/musical_group",
    "name" : "Musical Group",
    "type" : ["/type/type","/freebase/type_profile"]
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            We learn from this query that the English name of the specified object is "The Police". And, in addition to obtaining the ids of the four types of which The Police is a member, we also obtain the human-readable names of those types.
          </p>
          <p>
            Let's use this query technique to learn more about the tracks on the album Synchronicity. (The result lists only two tracks for brevity.)
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : [{}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type":  "/music/album",
  "name": "Synchronicity",
  "artist": "The Police",
  "track" : [{
    "id" : "/guid/9202a8c04000641f800000000120b4ca",
    "name" : "Synchronicity II",
    "type" : [
      "/music/track",
      "/music/song",
      "/music/composition"
    ]
  },{
    "id" : "/guid/9202a8c04000641f8000000001275dd7",
    "name" : "King of Pain",
    "type" : ["/music/track"]
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query doesn't actually tell us much about the tracks themselves. We already know the type of the tracks. The id might be useful in future queries, but it doesn't tell us anything about the track. The name is useful, but we could have obtained that without using curly braces, just by querying <code class="literal">"track":[]</code>.
          </p>
          <p>
            When you ask Metaweb to fill in empty curly braces for you, it returns all the properties if the value is a value type. The <code class="literal">name</code> property of an object is of <code class="literal">/type/text</code>, and querying it with <code class="literal">{}</code> returns all of its properties. If the property is an object type instead of a value type, then Metaweb returns only the <code class="literal">name</code>, <code class="literal">type</code> and <code class="literal">id</code> properties (all of which are defined by <code class="literal">/type/object</code> and are common to all Metaweb objects). That is, instead of using <code class="literal">[{}]</code>, we could write out the query explicitly like this:
          </p>
          <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : [{
    "name" : null,
    "id" : null,
    "type" : []
  }]
}
</pre>
          <p>
            If we want to know more about an object than its name, id, and types, then we must refine our query to express exactly what it is we would like to know. Here's how we ask for just the name and length of each of the tracks:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : [{
     "name":null,
     "length":null
  }]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : [
    {"name":"Synchronicity II", "length":305.066},
    {"name":"Every Breath You Take", "length":254.066},
    {"name":"King of Pain", "length":299.066},
    {"name":"Wrapped Around Your Finger", "length":313.733},
    {"name":"Tea in the Sahara", "length":255.44},
    {"name":"Walking in Your Footsteps", "length":216.773},
    {"name":"Miss Gradenko", "length":120},
    {"name":"Murder by Numbers", "length":276.8},
    {"name":"O My God", "length":242.226},
    {"name":"Synchronicity I", "length":202.866},
    {"name":"Mother", "length":185.64}
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="defaultproperties" name="defaultproperties"></a>3.2.8. Expanded Values and Default Properties
                </h3>
              </div>
            </div>
          </div>
          <p>
            In this tutorial we've said that we query the value of a property <code class="literal">p</code> with <code class="literal">"p":null</code> and "expand" that value into an object with <code class="literal">"p":{}</code>. This is helpful terminology, but it is actually the opposite of what is really going on. Everything in Metaweb is an object (or, in the case of literal values, can be viewed as an object). When you use curly braces, objects are naturally expressed as objects. When you use <code class="literal">null</code>, however, objects are compressed: instead of returning the complete object, Metaweb returns only one property – called the default property – of the object. The query <code class="literal">"p":null</code> really means "look up the expected type of the property <code class="literal">p</code>, then look up the default property of that type and return the value of that default property of the object that <code class="literal">p</code> refers to".
          </p>
          <p>
            If the expected type of a property is a primitive type, then the default property is <code class="literal">value</code>. If the expected type is not a system type (i.e. if it is not in the <code class="literal">/type</code> domain) then the default property is <code class="literal">name</code>. If the expected type is a system type, then the default property depends on the type but is usually <code class="literal">id</code> instead of <code class="literal">name</code>.
          </p>
          <p>
            Default properties are not only used when you ask Metaweb to fill in a <code class="literal">null</code> or a <code class="literal">[]</code> for you. They are also used when you express the information you already have. Consider the following query:
          </p>
          <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : []
}
</pre>
          <p>
            This query could also be expressed more verbosely like this:
          </p>
          <pre class="programlisting">{
  "type" : "/music/album",
  "name" : {"value":"Synchronicity", "lang":"/lang/en"},
  "artist" : {"name":"The Police"},
  "track" : []
}
</pre>
          <p>
            The verbose form of the query illustrates the fact that the succinct form relies on default properties. The <code class="literal">name</code> property is expected to be of <code class="literal">/type/text</code>, whose default property is <code class="literal">value</code>. The <code class="literal">artist</code> property is expected to be of type <code class="literal">/music/artist</code>, whose default property is <code class="literal">name</code>.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="reviewvaluequeries" name="reviewvaluequeries"></a>3.2.9. Review: Asking for Values
                </h3>
              </div>
            </div>
          </div>
          <p>
            If you want to ask Metaweb to return a value, use one of the terms listed in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#termtab" title="Table 3.1. Asking for Values">Table 3.1</a> on the right-hand side of a property name:
          </p>
          <div class="table">
            <a id="termtab" name="termtab"></a>
            <p class="title">
              <b>Table 3.1. Asking for Values</b>
            </p>
            <div class="table-contents">
              <table border="1" summary="Asking for Values">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Term
                    </th>
                    <th>
                      Meaning
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <code class="literal">null</code>
                    </td>
                    <td>
                      <p>
                        If the property is of value type, return the <code class="literal">value</code> property. Otherwise, the property refers to an object. If the object is of a system type in the <code class="literal">/type</code> domain, return the value of its default property (this is usually the <code class="literal">id</code> property). Otherwise, return the <code class="literal">name</code> of the object.
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">[]</code>
                    </td>
                    <td>
                      <p>
                        Like <code class="literal">null</code>, but return an array of values instead of a single value.
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">{}</code>
                    </td>
                    <td>
                      <p>
                        If the property is of value type, return an object that represents the value. This object will have <code class="literal">type</code> and <code class="literal">value</code> properties. If the property is <code class="literal">/type/text</code>, the returned object will also have a <code class="literal">lang</code> property, and if it is of <code class="literal">/type/key</code>, it will have a <code class="literal">namespace</code> property.
                      </p>
                      <p>
                        If the property is of object type, return an object that includes its <code class="literal">name</code>, <code class="literal">id</code>, and <code class="literal">type</code> properties. In this case, the term <code class="literal">{}</code> is equivalent to: <code class="literal">{"name":null,"id":null,"type":[]}</code>.
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">[{}]</code>
                    </td>
                    <td>
                      <p>
                        Like <code class="literal">{}</code>, but return an array of objects instead of a single one.
                      </p>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div><br class="table-break">
        </div>
      </div>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title">
                <a id="names" name="names"></a>3.3. Names, Ids, Keys and Namespaces
              </h2>
            </div>
          </div>
        </div>
        <p>
          Metaweb defines a few different ways to name objects. This section begins with a review of names, ids, guids, keys and namespaces, repeating some of the material from <a class="xref" href="http://mql.freebaseapps.com/ch02.html#namesandids" title="2.3. Names, Identifiers and Namespaces">Section 2.3</a>. After this overview, it demonstrates, with queries, many of the important features of names, ids, and namespaces.
        </p>
        <p>
          Every Metaweb object has a <code class="literal">name</code> property which can be used to specify or query a human-readable name (such as "The Police") for the object. Names are of <code class="literal">/type/text</code> and have a language (of <code class="literal">/type/lang</code>) associated with them. An object may have more than one name, but is only allowed to have one name per language. The <code class="literal">name</code> property of an object usually behaves, therefore, as if it has a single value. Names do not uniquely identify single objects: multiple objects may (and often do) share the same name.
        </p>
        <p>
          In addition to its human-readable name or names, every Metaweb object has zero or more fully-qualified names or identifiers. These are hierarchical names that use the <code class="literal">/</code> character in the way filesystems do. They are intended for use by Metaweb developers and are not typically displayed to end-users of Metaweb-based applications. Fully-qualified names are of <code class="literal">/type/id</code>, and are values of the <code class="literal">id</code> property of an object. <code class="literal">/music/album</code> is a fully-qualified name, and so is <code class="literal">/en/the_police</code>. A fully-qualified name uniquely identifies a single object, but is not immutable: fully-qualified names can be deleted or re-assigned to other objects. Use the <code class="literal">id</code> property to query or specify the fully-qualified name of an object.
        </p>
        <p>
          An object may have more than one fully-qualified name. In a query, you can specify an object by giving any of its fully-qualified names as the value of the <code class="literal">id</code> property. If you query the <code class="literal">id</code> of an object that has more than one fully-qualified name, the name that is returned is arbitrary.
        </p>
        <p>
          Every object in a Metaweb database has exactly one globally unique identifier or <span class="emphasis"><em>guid</em></span>. Guids are machine-readable hexadecimal numbers 32 digits (128 bits) long. They serve as universally-unique identifiers – no two objects (even objects retrieved from different Metaweb databases) will ever have the same guid. If you query the <code class="literal">id</code> property of an object that does not have any fully-qualified names, Metaweb will return a pseudo-id based on the object's guid. For example:
        </p>
        <pre class="programlisting">/guid/9202a8c04000641f800000000006df1b
</pre>
        <p>
          The fully-qualified names of an object are defined by its keys. These are the <code class="literal">/type/key</code> values of the <code class="literal">key</code> property. Each key consists of an unqualified name (the <code class="literal">value</code> of the key) and a namespace (the <code class="literal">namespace</code> of the key). The namespace is another Metaweb object, and it is usually referred to by <span class="emphasis"><em>its</em></span> fully-qualified name. The fully-qualified name <code class="literal">/en/the_police</code>, for example, has a value (or unqualified name) of "the_police" and a namespace whose id is <code class="literal">/en</code>. That namespace object has a key whose value is "en" and whose namespace is the special root namespace object whose id is <code class="literal">/</code>.
        </p>
        <p>
          A namespace may not contain two keys with the same name – this is another way of saying that a fully-qualified name must uniquely refer to a single object. A namespace may normally define two distinct names that refer to the same object. It is possible, however, to define "unique namespaces" in which there is a one-to-one mapping between names and objects: each name refers to a single object, and each object has only a single name (in that namespace).
        </p>
        <p>
          Working with keys can be confusing, and there is a shortcut that is sometimes useful. Some types define properties that are known as enumerations. The definition of an enumeration specifies a namespace, and the value of the property serves as a name within that namespace. Setting the value of an enumerated property of an object defines a fully-qualified name for the object.
        </p>
        <p>
          We'll see examples of names, ids, keys and enumerations in the sub-sections that follow.
        </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="namesanduniqueness" name="namesanduniqueness"></a>3.3.1. Names and Per-Language Uniqueness
                </h3>
              </div>
            </div>
          </div>
          <p>
            The <code class="literal">name</code> property of any Metaweb object is special because it behaves like a unique property (you can safely query it with <code class="literal">null</code> instead of <code class="literal">[]</code>, for example) even though it is not truly unique. Any Metaweb object can have multiple names, but may have only one name in any given language. That is, the <code class="literal">name</code> property is unique on a per-language basis. When you query the name of an object, Metaweb returns its name (if it has one) in your preferred language. (The desired language is specified as a parameter to the <span class="emphasis"><em>mqlread</em></span> query service: see <a class="xref" href="http://mql.freebaseapps.com/ch04.html#preferredlanguage" title="4.2.4.3. Specifying Your Preferred Language">Section 4.2.4.3</a>.)
          </p>
          <p>
            To demonstrate the special behavior of the <code class="literal">name</code> property, we must choose a topic that has translations into other languages. Let's ask about the name of the object with <code class="literal">id</code> "/en/united_states":
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":"United States"
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The "en" in the namespace of the id stands for English, so it is not surprising that the English name of this object matches the id. Now let's ask for more details about the name:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":{}
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name" : {
    "type" : "/type/text",
    "value" : "United States",
    "lang" : "/lang/en"
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This confirms that the name "United States" is an English name. Now let's ask for all names of the object:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":[]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":["United States"]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query just returns the unique English name in an array. So let's try again and ask for all names, along with the languages in which they are encoded:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":[{}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name" : [
    {"lang":"/lang/en","type":"/type/text",
     "value":"United States"},
    {"lang":"/lang/es","type":"/type/text",
     "value":"Estados Unidos de América"},
    {"lang":"/lang/fr","type":"/type/text",
     "value":"États-Unis d'Amérique"},
    {"lang":"/lang/it","type":"/type/text",
     "value":"Stati Uniti d'America"},
    {"lang":"/lang/de","type":"/type/text",
     "value":" Vereinigte Staaten"},
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Bingo! We find that this object has a number of names (only some of which are listed here).
          </p>
          <p>
            Here's how we can ask for a name of the object in a specific language other than our preferred language:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name":{
    "value":null,
    "lang":"/lang/fr"
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/united_states",
  "name": {
    "value": "États-Unis d'Amérique",
    "lang": "/lang/fr"
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The default preferred language (and the one used throughout this chapter) is English. We'll learn how to specify a different language in <a class="xref" href="http://mql.freebaseapps.com/ch04.html#preferredlanguage" title="4.2.4.3. Specifying Your Preferred Language">Section 4.2.4.3</a>.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2950817" name="id2950817"></a>3.3.2. Ids
                </h3>
              </div>
            </div>
          </div>
          <p>
            The most important thing about the <code class="literal">id</code> property is that if you specify its value, you are uniquely identifying a single object in the database. A query that specifies <code class="literal">id</code> need not have square brackets around it: it can never return more than one value. It is also a good rule of thumb (though not always strictly necessary) to put square brackets around any query that does not specify the <code class="literal">id</code> property.
          </p>
          <p>
            It is always safe to query the id of an object with <code class="literal">"id":null</code>. This query will always return exactly one value (even if the object has more than one fully-qualified name). If the object does not have any fully-qualified names, Metaweb returns a pseudo-id using the object's guid and the <code class="literal">/guid</code> namespace. For example:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "artist": "The Police",
  "name" : "Synchronicity",
  "id" : null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "artist" : "The Police",
  "name" : "Synchronicity",
  "id" : "/guid/9202a8c04000641f8000000002f9e349"
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            There is a one-to-one mapping between objects and guids: every object has one guid, and every valid guid must refer to a different object. Ids are less strict: no two objects can have the same id, but an object can have zero, one, or more fully-qualified names. We can refer to the Metaweb object that represents the band The Police with any of the following:
          </p>
          <pre class="programlisting">"id":"/guid/9202a8c04000641f800000000006df1b"
"id":"/en/the_police"
"id":"/wikipedia/en_id/57321"
"id":"/wikipedia/en/Police_band"
</pre>
          <p>
            There are some restrictions on what you can do with the <code class="literal">id</code> property: it cannot be used as a sort key, and it cannot be used with operators such as <code class="literal">~=</code> and <code class="literal">&lt;</code> (We'll learn about sorting and operators later in this chapter.)
          </p>
          <p>
            Also, you cannot query all the fully-qualified names of an object with <code class="literal">"id":[]</code>:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "id" : []
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type": "/music/artist",
  "name": "The Police",
  "id": ["/en/the_police"]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            <code class="literal">"id":[]</code> returns a single valid id for the object, just as <code class="literal">"id":null</code> does, but it wraps it in square brackets. To find multiple fully-qualified names of an object, you must query its keys, which are the topic of the next section.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="keysandnamespaces" name="keysandnamespaces"></a>3.3.3. Keys and Namespaces
                </h3>
              </div>
            </div>
          </div>
          <p>
            To ask for multiple fully-qualified names for an object, query its <code class="literal">key</code> property. The following query asks for all properties of all keys of The Police.
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/the_police",
  "key":[{}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "key" : [{
    "type" : "/type/key",
    "namespace" : "/en",
    "value" : "the_police"
  },{
    "type" : "/type/key",
    "namespace" : "/wikipedia/en_id",
    "value" : "57321"
  },{
    "type" : "/type/key",
    "namespace" : "/wikipedia/en",
    "value" : "Police_band"
  },{
    "type" : "/type/key",
    "namespace" : "/wikipedia/en",
    "value" : "The_Police_$0028band$0029"
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The results of this query have been truncated, but there are two things worth noting about the representative keys shown here. First, fully-qualified names can contain numbers and underscores, but they cannot contain punctuation. If a local name contains punctuation such as parentheses, these must be escaped using Unicode codepoints. For example, $0028 in a fully-qualified name represents a left parenthesis and $0029 represents a right parenthesis. (See <a class="xref" href="http://mql.freebaseapps.com/ch02.html#typekey" title="2.5.9. /type/key">Section 2.5.9</a> for the full list of legal characters in fully-qualified names.)
          </p>
          <p>
            Second, note that these keys do not include a key in the <code class="literal">/guid</code> namespace. <code class="literal">/guid</code> ids are synthesized by Metaweb when no fully-qualified name exists: they do not represent a real key.
          </p>
          <p>
            The query above returns keys representing multiple fully-qualified names for The Police. Those results are not necessarily a complete list, however. The keys refer to namespaces, and the namespaces themselves can have more than one fully-qualified name. Consider the <code class="literal">/en</code> namespace:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en",
  "key":[{}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en",
  "key" : [{
    "type" : "/type/key",
    "namespace" : "/topic",
    "value" : "en"
  },{
    "type" : "/type/key",
    "namespace" : "/",
    "value" : "en"
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query tells us that our namespace object has the name "en" in the root namespace <code class="literal">/</code>, but that it also has the name "en" in the namespace <code class="literal">/topic</code>. This means that the fully-qualified name <code class="literal">/en/the_police</code> can also be written as <code class="literal">/topic/en/the_police</code>.
          </p>
          <p>
            The keys of an object all refer to namespace objects in which those keys are defined. Since Metaweb links are bi-directional, it must also be possible to query a namespace to find out what names are defined in it. Here's a query on the <code class="literal">/topic</code> namespace. It queries the <code class="literal">key</code> property we've already seen to ask for the fully-qualified names of this object. But it also queries the <code class="literal">keys</code> property to find out what keys are defined in <code class="literal">/topic</code>. (The <code class="literal">key</code> property is defined by <code class="literal">/type/object</code>. The <code class="literal">keys</code> property is defined by <code class="literal">/type/namespace</code>, and is plural to avoid naming conflicts with <code class="literal">key</code>.):
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type":"/type/namespace",
  "id":"/topic",
  "key":[{}],
  "keys":[{}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/type/namespace",
  "id" : "/topic",
  "key" : [{
    "namespace" : "/",
    "type" : "/type/key",
    "value" : "topic"
    }],
  "keys" : [{
    "namespace" : "/en",
    "type" : "/type/key",
    "value" : "en"
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The results tell us that the object <code class="literal">/topic</code> has only the one fully-qualified name we already know: the local name "topic" in the namespace <code class="literal">/</code>. They also tell us that there is only a single key defined in the <code class="literal">/topic</code> namespace. This key has the local name "en", which means that it defines the fully-qualified name <code class="literal">/topic/en</code>.
          </p>
          <p>
            Both the <code class="literal">key</code> and <code class="literal">keys</code> properties return values of <code class="literal">/type/key</code>. The <code class="literal">namespace</code> properties of these keys have different meanings, however. When you query the <code class="literal">key</code> property of an object, the <code class="literal">namespace</code> property of each returned key refers to the namespace object in which the key is defined. When you query the <code class="literal">keys</code> property of a namespace, however, the <code class="literal">namespace</code> property of each returned key specifies the object whose name is defined by that key. So the query above tells us that the <code class="literal">/topic</code> namespace defines a key named "en" that refers to an object with id <code class="literal">/en</code>. That is <code class="literal">/topic/en</code> is another fully-qualified name for <code class="literal">/en</code>.
          </p>
          <p>
            Finally, it is worth noting that any Metaweb object can serve as a namespace, even if it does not have a <code class="literal">type</code> property of <code class="literal">/type/namespace</code>. Types (such as <code class="literal">/music/artist</code>) have ids that use the domain (<code class="literal">/music</code>) as a namespace, and properties (such as <code class="literal">/music/artist/album</code> have ids that use the type as a namespace. At the time of this writing, <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2951364" id="id2951364" name="id2951364">12</a>]</sup> Metaweb domains and types very often do not have <code class="literal">/type/namespace</code> among their types. Despite these examples, it is not recommended practice to use an object as a namespace without typing it as a namespace.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2951382" name="id2951382"></a>3.3.4. Namespaces and Uniqueness
                </h3>
              </div>
            </div>
          </div>
          <p>
            A namespace can define any number of keys, but the <code class="literal">value</code> property of each key must be different. Otherwise, the same fully-qualified name would be defined twice, and could refer to more than one object. On the other hand, the reverse is not necessarily true: normal namespaces can define multiple keys that refer to the same object. For example, we've already seen that the <code class="literal">/wikipedia/en</code> namespace defines "Police_band" and "The_Police_$0028band$0029" as names for the same object.
          </p>
          <p>
            Not all namespaces allow multiple names for the same object, however. A namespace may be declared to be "unique", and unique namespaces enforce a one-to-one mapping between names and objects: each name can refer to only one object and each object can have only one name. The <code class="literal">/user</code> and <code class="literal">/lang</code> namespaces are unique, which means that each user and language can have only a single fully-qualified name (assuming that <code class="literal">/user</code> and <code class="literal">/lang</code> don't have any other ids themselves). Most other namespaces, such as <code class="literal">/en</code> are not unique. Unique namespaces have the <code class="literal">unique</code> property of <code class="literal">/type/namespace</code> set to <code class="literal">true</code>. Namespaces that are not unique typically have <code class="literal">null</code> for this property.
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/lang",
  "type":"/type/namespace",
  "unique":null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/lang",
  "type" : "/type/namespace",
  "unique" : true
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="enumerations" name="enumerations"></a>3.3.5. Enumerations
                </h3>
              </div>
            </div>
          </div>
          <p>
            An <span class="emphasis"><em>enumeration</em></span> is MQL's mechanism for connecting a type with the namespace that defines names for objects of that type. An enumeration takes the form of a property whose expected type is <code class="literal">/type/enumeration</code>. If a type has a property like this, then setting the value of that property on an object defines a key in the associated namespace. The property value is the name of the key, and the key refers to the object on which the property was set. Similarly, if you create a name in the namespace that refers to an object, then that object automatically gets a value for the property.
          </p>
          <p>
            The type <code class="literal">/type/lang</code> is associated with the namespace <code class="literal">/lang</code> through the enumerated property <code class="literal">iso639</code>. (ISO639 is the name of an international standard defining short codes such as "en" and "fr" for language names.) This means that for any object of <code class="literal">/type/lang</code>, the value of the <code class="literal">iso639</code> property is also a used to define a fully-qualified name in the the <code class="literal">/lang</code> namespace. The following query (and partial set of results) demonstrates:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type":"/type/lang",
  "name":null,
  "id":null,
  "iso639":null
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/type/lang",
  "name":"English",
  "id" : "/lang/en",
  "iso639" : "en"
},{
  "type" : "/type/lang",
  "name":"German",
  "id" : "/lang/de",
  "iso639" : "de"
},{
  "type" : "/type/lang",
  "name":"Spanish",
  "id" : "/lang/es",
  "iso639" : "es"
},{
  "type" : "/type/lang",
  "name":"French",
  "id" : "/lang/fr",
  "iso639" : "fr"
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            <code class="literal">/type/lang</code> defines the <code class="literal">iso639</code> property so that its value becomes part of the fully-qualified name of the object. In a sense, then, this <code class="literal">iso639</code> property is the "unqualified name" or "local id" of every <code class="literal">/type/lang</code> object. So language objects have a human-readable <code class="literal">name</code>, a fully-qualified, hierarchical <code class="literal">id</code>, and this local name, the values of which are defined (or "enumerated") by international standard ISO639.
          </p>
          <p>
            Let's investigate the <code class="literal">iso639</code> property itself:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type":"/type/property",
  "id":"/type/lang/iso639",
  "expected_type":null,
  "enumeration":null,
  "unique":null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/type/property",
  "id" : "/type/lang/iso639",
  "expected_type" : "/type/enumeration",
  "enumeration" : "/lang",
  "unique" : true
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            We see from this query that the property has expected type <code class="literal">/type/enumeration</code>, and that it has a property named <code class="literal">enumeration</code> that refers to associated namespace. Since we already know that the <code class="literal">/lang</code> namespace is unique (no language can have more than one name in the namespace), it follows that this <code class="literal">iso639</code> property must also be defined as a unique property: it cannot make sense to have more than one value for the property.
          </p>
          <p>
            The <code class="literal">userid</code> property of <code class="literal">/type/user</code> is an important enumeration that links <code class="literal">/type/user</code> objects with the <code class="literal">/user</code> namespace. Another notable example involves taxonomy. The type <code class="literal">/biology/organism_classification</code> has two enumerated properties: the <code class="literal">itis_tsn</code> property links to the <code class="literal">/biology/itis</code> namespace and the <code class="literal">ncbi_taxon_id</code> links to the <code class="literal">/biology/ncbi</code> namespace. For example, the Metaweb object representing the species <span class="emphasis"><em>Equus caballus</em></span> (horses) has its <code class="literal">itis_tsn</code> property set to "180691" and its <code class="literal">ncbi_taxon_id</code> set to "9796" and can be referred to as: <code class="literal">/biology/itis/180691</code> or <code class="literal">/biology/ncbi/9796</code>. For this type, neither the enumerated properties nor the namespaces they refer to are marked unique, which means that either the ITIS or NCBI classification scheme may allow multiple names for the same species.
          </p>
          <p>
            It should be clear from these examples that MQL enumerations are not really the same thing as the "enumerated types" (a type that has a small, pre-defined set of allowed values) that are supported by some programming languages. The name "enumeration" refers to the fact that the namespace associated with the enumerated property enumerates instances of the type. As the examples above have shown, enumerations are most useful when there is an external authority (such as an international standard) that defines the names.
          </p>
          <p>
            Recall that the names defined in namespaces are restricted to using letters, numbers, and underscores. Any other characters must be written as a dollar sign followed by the four hexadecimal digits of its Unicode codepoint. MQL does not impose this restriction on enumerated properties. Instead, it transparently escapes and un-escapes names as needed. That is, if you set the value of an enumerated property to a string that contains a punctuation character, that character will automatically be escaped in the namespace. Similarly, if a key contains escaped punctuation but you read it through an enumerated property, the escapes will be replaced by the characters they represent. This can't be demonstrated using the <code class="literal">/lang</code>, <code class="literal">/user</code> or <code class="literal">/biology</code> namespaces we've mentioned here, since none of them define names that include punctuation. But we'll see an example in <a class="xref" href="http://mql.freebaseapps.com/ch05.html" title="Chapter 5. The MQL Write Grammar">Chapter 5</a> when we define our enumerated properties for types of our own.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2951832" name="id2951832"></a>3.3.6. GUIDs
                </h3>
              </div>
            </div>
          </div>
          <p>
            If you query the <code class="literal">id</code> of an object, Metaweb returns one of its fully-qualified names, if it has any. If it has none, Metaweb returns a synthetic identifier based on the guid of the object. Fully-qualified names and guids both uniquely identify a single object, but there is an important difference between them. Fully-qualified names are defined by keys that are separate from the object itself, and these keys are mutable. A fully-qualified name may be deleted and refer to no object at all. Or it may be modified so that it refers to an new object. If you run a query that identifies an object by its fully-qualified name, that query may (though this is unlikely) refer to a different object each time you run it, or it may fail because the fully-qualified name now refers to no object at all.
          </p>
          <p>
            Guids, on the other hand, are intrinsic to the object and are persistent and immutable: a guid is assigned when an object is created, and it always refers to that object. If you want to be sure that a query always refers to exactly the same object, use the object's guid. If an object has a fully-qualified name, you cannot obtain its guid by querying the <code class="literal">id</code> property. In this case, query the <code class="literal">guid</code> property:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name": "The Police",
  "guid" : null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "guid" : "#9202a8c04000641f800000000006df1b"
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            For historical reasons, the value returned by the <code class="literal">guid</code> property has a leading <code class="literal">#</code> character. You can use this value, with its leading hash, as the value of the <code class="literal">guid</code> property, or you can replace the <code class="literal">#</code> with <code class="literal">/guid/</code> and use the modified string as the value of the <code class="literal">id</code> property. In either case, you'll always refer to the original object, even if the fully-qualified names that used to refer to that object now refer to other objects.
          </p>
          <p>
            Applications that use guids tend to be more brittle and less resilient to database changes than applications that use fully-qualified names, so the use of the <code class="literal">guid</code> property is generally discouraged.
          </p>
        </div>
      </div>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title">
                <a id="properties" name="properties"></a>3.4. Property Names in MQL Queries
              </h2>
            </div>
          </div>
        </div>
        <p>
          So far in this chapter, we've seen simple property names to the left of the colon in MQL queries. This section explores property names in more depth, explaining how to use qualified property names, property name prefixes, and property name wildcards. In addition to property names, this section also explores <code class="literal">/type/property</code> objects themselves. Later in this chapter, we'll learn about directives and operators. Directives are special MQL commands that appear to the left of the colon in place of a property name. And operators are punctuation that are added on to the end of the property name.
        </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="fullpropertyids" name="fullpropertyids"></a>3.4.1. Simple and Qualified Property Names
                </h3>
              </div>
            </div>
          </div>
          <p>
            Recall from the beginning of this tutorial that most objects in Metaweb have two or more types:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/the_police",
  "name":null,
  "type":[]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "name" : "The Police",
  "type" : [
    "/music/artist",
    "/common/topic",
    "/music/producer",
    "/music/musical_group"
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            What do you do if you want to query one property, such as a list of albums from one type, and another property, such as a list of images, from a second type? MQL addresses this issue by allowing you to specify a fully-qualified property name that includes the name of the type to which it belongs. So here is how we ask for the albums, tracks and pictures by and of The Police:
          </p>
          <pre class="programlisting">1 {
2   "type":"/music/artist",
3   "name":"The Police",
4   "album":[{
5      "name":null
6      "track":[]
7   }],
8   "/common/topic/image":[{}]
9 }
</pre>
          <p>
            Line 2 specifies that the object to be matched should be of type <code class="literal">/music/artist</code>. Line 3 specifies the name of the object. <code class="literal">name</code> and <code class="literal">type</code> are properties of <code class="literal">/type/object</code>, and are shared by all objects in the database. These property names (along with <code class="literal">id</code>, <code class="literal">key</code>, etc.) can always be used without qualification (although you can qualify them with <code class="literal">/type/object</code> if you want to). Other types are not allowed to define properties whose names conflict with these.
          </p>
          <p>
            Line 4 asks for a property named <code class="literal">album</code>. This property is not defined by <code class="literal">/type/object</code>, but it is defined by <code class="literal">/music/artist</code>, and the query has already declared that the object will be an instance of that type, so MQL allows us to use this unqualified property name. Line 5 is like lines 2 and 3: it names a property shared by all objects. Line 6 is an interesting case. <code class="literal">track</code> is a property of <code class="literal">/music/album</code>. We can use it here without qualification because the <code class="literal">album</code> property to which this sub-query is attached was declared to have an "expected type" of /music/album. MQL knows this and assumes that the unqualified property name <code class="literal">track</code> means <code class="literal">/music/album/track</code>.
          </p>
          <p>
            Finally, line 8 asks for a property named <code class="literal">image</code>. This is not defined by <code class="literal">/type/object</code> nor by <code class="literal">/music/artist</code>, and so we must qualify it with the name of its type so that Metaweb can understand it.
          </p>
          <p>
            For symmetry, and to be explicit, you can rewrite the query (dropping the track portion) to fully-qualify both properties of interest:
          </p>
          <pre class="programlisting">{
  "type":"/music/artist",
  "name":"The Police",
  "/music/artist/album":[],
  "/common/topic/image":[{}]
}
</pre>
          <p>
            If you do this, you might be tempted to drop the initial <code class="literal">type</code> specification, since the <code class="literal">album</code> property is now fully-qualified:
          </p>
          <pre class="programlisting">[{
  "name":"The Police",
  "/music/artist/album":[],
  "/common/topic/image":[{}]
}]
</pre>
          <p>
            This is probably not the query you want, however: it returns any object whose name is The Police, even if it has no <code class="literal">album</code> or <code class="literal">image</code> properties, and even if it is an instance of neither <code class="literal">/music/artist</code> nor <code class="literal">/common/topic</code>.
          </p>
          <p>
            In addition to querying properties from two different types, there is another reason you might need to use fully-qualified names: you might want to query the value of a property without constraining the results to members of the type that defines the property. It may seem surprising, but the Metaweb architecture allows objects to have values for any property, even if the object does not declare itself to be a member of that type. Metaweb type objects are an example: they serve as a namespace for the properties they define, (the <code class="literal">album</code> property of <code class="literal">/music/artist</code> is <code class="literal">/music/artist/album</code>) but are not typically typed as namespaces (the set of types for <code class="literal">/music/artist</code> does not include <code class="literal">/type/namespace</code>). It is possible to query the namespace keys of an object, even if that object is not a namespace with a query like this:
          </p>
          <pre class="programlisting">{
  "id":"/music/album",
  "/type/namespace/keys":[{}]
}
</pre>
          <p>
            Without fully-qualified property names, we'd have to write this:
          </p>
          <pre class="programlisting">{
  "id":"/music/album",
  "type":"/type/namespace",
  "keys":[{}]
}
</pre>
          <p>
            But this query would simply return <code class="literal">null</code> because the object with an <code class="literal">id</code> of <code class="literal">/music/album</code> does not have <code class="literal">/type/namespace</code> in its set of types.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2952288" name="id2952288"></a>3.4.2. Property Prefixes
                </h3>
              </div>
            </div>
          </div>
          <p>
            Suppose we want to find the names of all bands who have an album named "Greatest Hits" AND an album named "Super Hits". We might try this query:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album":["Greatest Hits","Super Hits"]  // Invalid MQL
}]
</pre>
          <p>
            But this is not legal MQL. And if it was, it would probably mean find an artist who has recorded exactly two albums, with names "Greatest Hits" and "Super Hits". A musical artist object may have multiple <code class="literal">album</code> links to album objects. We want to constrain our query so that all result objects have links to two specific album names. Here's a natural way to express this query:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album":"Greatest Hits",
  "album":"Super Hits"      // Invalid JSON
}]
</pre>
          <p>
            This query makes sense in the Metaweb object model: find objects that have one "album" link to an album named "Greatest Hits" and another "album" link to an album named "Super Hits". Unfortunately, this query is not valid JSON: it includes the same property name twice, which means that cannot be parsed into object form. (To put this another way, you could not represent this query in a dictionary or hash data structure in a programming language like Python, Ruby or JavaScript.)
          </p>
          <p>
            MQL's solution to this dilemma is to allow an arbitrary identifier and colon to prefix any property name. The prefix and colon are ignored: they serve simply as a workaround to the JSON limitation just described. With this trick we can rewrite the query above like this:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "a:album":"Greatest Hits",
  "b:album":"Super Hits"
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type": "/music/artist",
  "name": "Alice Cooper",
  "a:album": "Greatest Hits",
  "b:album": "Super Hits"
},{
  "type": "/music/artist",
  "name": "Dan Fogelberg",
  "a:album": "Greatest Hits",
  "b:album": "Super Hits"
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Note that the arbitrary prefixes we choose for the query are repeated in the result objects. (The results shown here are truncated, of course.) The prefixes are arbitrary, but they must be valid identifiers which means they cannot contain punctuation characters and must not begin with a digit.
          </p>
          <p>
            Another use of property prefixes is to constrain a property and also query the property at the same time. Here's how we can identify an object by name and type, and also ask for its full set of types:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "constraint:type":"/music/artist",
  "name":"The Police",
  "query:type":[]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "constraint:type" : "/music/artist",
  "name" : "The Police",
  "query:type" : [
    "/music/artist",
    "/common/topic",
    "/music/producer",
    "/music/musical_group"
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Note that although property prefixes are arbitrary, we can choose identifiers like "constraint" and "query" that add meaning to our queries. In practice, it is common to see "a", "b", and "c" used as prefixes.
          </p>
          <p>
            Here is a more complex example that uses multiple prefixes to constrain and query properties at the same time. It asks for albums by solo artists (objects that are both <code class="literal">/music/artist</code> and <code class="literal">/people/person</code>) who have released Greatest Hits and Super Hits albums:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "also:type":"/people/person",
  "name":null,
  "album":[],
  "includes:album":"Greatest Hits",
  "and:album":"Super Hits"
}]
</pre>
          <p>
            Suppose that for symmetry we wanted to use a prefix before both of the type constraints in the query above, so that they looked like this:
          </p>
          <pre class="programlisting">  "primary:type":"/music/artist",
  "secondary:type":"/people/person"
</pre>
          <p>
            If we do this, the query fails with the message "Type /type/object does not have property album". If we put a prefix in front of the <code class="literal">type</code> property, MQL will not automatically search the specified type for properties. To make the query work with prefixed type properties, we must fully-qualify the <code class="literal">album</code> properties like this:
          </p>
          <pre class="programlisting">  "/music/artist/album":[],
  "includes:/music/artist/album":"Greatest Hits",
  "and:/music/artist/album":"Super Hits"
</pre>
          <p>
            As an interesting aside, let's return to the query with which we started this section. We want to find bands that have released "Greatest Hits" and "Super Hits" albums. There is actually a way to do this without property prefixes. It relies on the fact that Metaweb relationships are always bi-directional and that MQL queries can be "turned inside out":
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album":[{
    "name":"Greatest Hits",
    "artist":{
      "album":"Super Hits"
    }
  }]
}]
</pre>
          <p>
            Translated into English, this query says: "give me the names of all bands that have released an album named "Greatest Hits", the artist of which has released an album named "Super Hits". The <code class="literal">album</code> property of a band object refers to an album object. And the <code class="literal">artist</code> property of the album object refers back to the band object. We can use this fact to further constrain the artist. This technique is worth understanding because it illustrates one of the deep properties of Metaweb objects and MQL queries.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="wildcards" name="wildcards"></a>3.4.3. Wildcards
                </h3>
              </div>
            </div>
          </div>
          <p>
            MQL allows you to use the property name "*" as a wildcard. Consider the following query:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/guid/9202a8c04000641f8000000002f9e349",
  "*":null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/guid/9202a8c04000641f8000000002f9e349",
  "guid" : "#9202a8c04000641f8000000002f9e349",
  "name" : "Synchronicity",
  "type" : ["/music/album", "/common/topic"],
  "key" : ["RELEASE3178", "196871"],
  "creator" : "/user/mwcl_musicbrainz",
  "permission" : "/boot/all_permission",
  "timestamp" : "2006-12-10T12:23:59.0119Z"
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query identifies a unique object by guid, and then uses a wildcard to ask for all of its properties. Since no type has been specified, the wildcard is expanded with all the properties of <code class="literal">/type/object</code>, and the result is as shown above.
          </p>
          <p>
            Note that some of the properties expand to a single value, and others to arrays. Thus the syntax <code class="literal">"*":null</code> really means <code class="literal">"*":null-or-[]</code>. We could instead write the query using <code class="literal">"*":[]</code>. In this case, all of the property are returned as arrays, even unique properties.
          </p>
          <p>
            Now let's modify the query to specify a type other than the default of <code class="literal">/type/object</code>:
          </p>
          <pre class="programlisting">{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "*":null
}
</pre>
          <p>
            In this query, the <code class="literal">*</code> wildcard expands differently. Since we have specified that the object is of type <code class="literal">/music/album</code>, Metaweb looks up the properties of that type and queries each one with a <code class="literal">null</code> or <code class="literal">[]</code>, depending on whether the property is unique or not. It does this in addition to also querying the common object properties shown in the query result above.
          </p>
          <p>
            Note that if a property is explicitly listed in a query, a wildcard expansion will not overwrite it. Consider this:
          </p>
          <pre class="programlisting">{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track":[{}],
  "*":null
}
</pre>
          <p>
            This query explicitly asks for an array of tracks, as objects rather than just as track names. The expansion of the wildcard would normally include <code class="literal">"track":[]</code>, but in this case that property would conflict with the explicitly specified one and will be left out of the expansion.
          </p>
          <p>
            Metaweb will expand wildcards in sub-queries based on the type inferred from the expected type of the property. In this query, the <code class="literal">*</code> expands to <code class="literal">/type/object</code> and <code class="literal">/music/track</code> properties:
          </p>
          <pre class="programlisting">{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track":[{"*":null}]
}
</pre>
          <p>
            Now consider this query:
          </p>
          <pre class="programlisting">[{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":{
    "type":"/common/topic",
    "*":null
  }
}]
</pre>
          <p>
            Here the artist sub-query is expected to match an object of type <code class="literal">/music/artist</code>. But we've explicitly specified the type <code class="literal">/common/topic</code>, so in this case the wildcard expands to the properties of <code class="literal">/type/object</code> and <code class="literal">/common/topic</code>. The properties of <code class="literal">/music/artst</code> are not included in the expansion.
          </p>
          <p>
            Instead of writing a wildcard query as <code class="literal">"*":null</code>, you can also use another, more aggressive, form. <code class="literal">"*":{}</code> expands to query each property with <code class="literal">{}</code> or <code class="literal">[{}]</code> instead of <code class="literal">null</code> or <code class="literal">[]</code>. Similarly, <code class="literal">"*":[{}]</code> expands to query each property, even unique properties, with <code class="literal">[{}]</code>. Contrast the following queries, each of which returns more information than the one before it:
          </p>
          <pre class="programlisting">// List the names of albums by The Police
{
  "id":"/en/the_police",
  "/music/artist/album":[]
}

// List the names, types and ids of albums by The Police
{
  "id":"/en/the_police",
  "/music/artist/album":[{}]
}

// List all object and album properties of all albums by The Police
{
  "id":"/en/the_police",
  "/music/artist/album":[{"*":null}]
}

// Expand all object and album properties of all albums by The Police
{
  "id":"/en/the_police",
  "/music/artist/album":[{"*":{}}]
}
</pre>
          <p>
            A property name wildcard must be followed by <code class="literal">null</code>, <code class="literal">[]</code>, <code class="literal">{}</code> or <code class="literal">[{}]</code>. This means that wildcard queries cannot be nested. We cannot take the last query above another step and write:
          </p>
          <pre class="programlisting">{
  "id":"/en/the_police",
  "/music/artist/album":[{"*":{"*":null}}]  // Illegal
}
</pre>
          <p>
            The <code class="literal">*</code> property name wildcard queries the value of all properties based on the specified or inferred type of an object, and it queries those properties whether or not they have ever had a value assigned to them. MQL has another wildcard-like feature that allows us to query the value of all the properties of an object that have been defined, regardless of the type that defines those properties. This "reflective" capability is described in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#reflection" title="3.7.3. Reflection">Section 3.7.3</a>.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="inverseproperty" name="inverseproperty"></a>3.4.4. Inverting a Property with !
                </h3>
              </div>
            </div>
          </div>
          <p>
            If you put an exclamation point before the name of a property, you are asking MQL to run the query using the reciprocal of the property you have named. To put this another way, a MQL property specifies a link between two objects, and the ! prefix asks MQL to follow that link backwards. The following two queries, for example, are equivalent:
          </p>
          <pre class="programlisting">// Return albums by the police
{
  "id" : "/en/the_police",
  "/music/artist/album" : []
}

// Return albums for which the artist property refers to this object
{
  "id" : "/en/the_police",
  "!/music/album/artist" : []
}
</pre>
          <p>
            All Metaweb links are bi-directional, but not all properties have a reciprocal defined. The ! prefix is useful in these cases where you want to use a reverse property that has not been defined. The type <code class="literal">/people/person</code> defines a <code class="literal">nationality</code> property, with an expected type of <code class="literal">/location/country</code>, for example. But <code class="literal">/location/country</code> does not (or did not when this was written) define a reciprocal <code class="literal">citizen</code> property. So to ask Freebase for a list of citizens of Monaco, we could write:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/location/country",
  "name" : "Monaco",
  "!/people/person/nationality" : []
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/location/country",
  "name" : "Monaco",
  "!/people/person/nationality" : [
    "Olivier Beretta",
    "Louis Chiron",
    "Sebastien Gattuso",
    "Armand Forcherio",
    "Torben Joneleit",
    "Sophiane Baghdad",
    "Manuel Vallaurio"
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            We could, of course have written an equivalent query like this:
          </p>
          <pre class="programlisting">[{
  "type" : "/people/person",
  "name" : null,
  "nationality" : "Monaco"
}]
</pre>
          <p>
            This query returns the same set of names, but the result is much more verbose, with <code class="literal">type</code> and <code class="literal">nationality</code> properties repeated unnecessarily for each person returned.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2953002" name="id2953002"></a>3.4.5. Property Objects
                </h3>
              </div>
            </div>
          </div>
          <p>
            As explained in <a class="xref" href="http://mql.freebaseapps.com/ch02.html#coretypes" title="2.6.1. Core Types">Section 2.6.1</a>, the properties of a Metaweb type are represented by objects of <code class="literal">/type/property</code>. Let's use a wildcard to query all the properties of the <code class="literal">album</code> property of the <code class="literal">/music/artist</code> type:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/music/artist/album",
  "type":"/type/property",
  "*":null
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/music/artist/album",
  "type" : "/type/property",
  "name" : "Albums",
  "key" : [ "album" ],
  "expected_type" : "/music/album",
  "schema" : "/music/artist",
  "unique" : null,
  "master_property" : "/music/album/artist",
  "reverse_property" : null,
  "delegated" : null,
  "enumeration" : null,
  "links" : [],
  "unit" : null
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The sub-sections that follow explain the results of this query in detail. (For simplicity, some <code class="literal">/type/object</code> properties that are not relevant here have been omitted from these results).
          </p>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="id2953086" name="id2953086"></a>3.4.5.1. Property Names and Keys
                  </h4>
                </div>
              </div>
            </div>
            <p>
              The property we queried above has the name "Albums" and the key <code class="literal">album</code>. This key is a name defined in the <code class="literal">/music/artist</code> namespace, giving the property the fully-qualified name <code class="literal">/music/artist/album</code>. It is important to understand that when we refer to a "property name" in discussions of MQL, we almost always mean its fully-qualified name, or the unqualified name defined by its key. The name "Albums" appears in the Freebase client when you explore the <code class="literal">/music/artist</code> type, but it is never used in MQL queries. When writing MQL, we use the key: <code class="literal">album</code>.
            </p>
          </div>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="id2953125" name="id2953125"></a>3.4.5.2. Property Type and Schema
                  </h4>
                </div>
              </div>
            </div>
            <p>
              Every <code class="literal">/type/property</code> object has two types associated with it. <code class="literal">expected_type</code> is the type that the property value is expected to have. (This is called an "expected" type because Metaweb does not enforce it. MQL makes the assumption that property values match their expected type, but in practice any property can refer to an object of any type.) The <code class="literal">schema</code> is the type of which the property is a part. So the <code class="literal">/music/artist/album</code> property we queried above has an <code class="literal">expected_type</code> of <code class="literal">/music/album</code> and a <code class="literal">schema</code> of <code class="literal">/music/artist</code>.
            </p>
          </div>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="id2953174" name="id2953174"></a>3.4.5.3. Unique Properties
                  </h4>
                </div>
              </div>
            </div>
            <p>
              The <code class="literal">unique</code> property of a property object specifies whether the property is unique. Unique properties have <code class="literal">"unique":true</code>:
            </p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Query
                    </th>
                    <th>
                      Result
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <pre class="programlisting">{
  "id":"/music/track/length",
  "/type/property/unique":null
}
</pre>
                    </td>
                    <td>
                      <pre class="programlisting">{
  "id" : "/music/track/length",
  "/type/property/unique" : true
}
</pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              Non-unique properties can have the value <code class="literal">false</code>, but are more likely to have this property unset and return <code class="literal">"unique":null</code>.
            </p>
          </div>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="reciprocalprops" name="reciprocalprops"></a>3.4.5.4. Reciprocal Properties
                  </h4>
                </div>
              </div>
            </div>
            <p>
              Links between objects in the Metaweb database are inherently bidirectional. Types, like <code class="literal">/music/artist</code> and <code class="literal">/music/album</code>, that are designed to work together, often take advantage of this bi-directionality by declaring pairs of reciprocal properties. Any link between an artist and an album result is visible through he <code class="literal">/music/artist/album</code> property and also through its reciprocal <code class="literal">/music/album/artist</code>.
            </p>
            <p>
              The reciprocity of properties is apparent through the <code class="literal">master_property</code> and <code class="literal">reverse_property</code> properties. When we queried <code class="literal">/music/artist/album</code> above, we learned that it has a <code class="literal">master_property</code> of <code class="literal">/music/album/artist</code> and a <code class="literal">reverse_property</code> of <code class="literal">null</code>. Let's query the reciprocal property now:
            </p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Query
                    </th>
                    <th>
                      Result
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <pre class="programlisting">{
  "id":"/music/album/artist",
  "type":"/type/property",
  "master_property":null,
  "reverse_property":null
}
</pre>
                    </td>
                    <td>
                      <pre class="programlisting">{
  "id":"/music/album/artist",
  "type":"/type/property",
  "master_property":null,
  "reverse_property":"/music/artist/album"
}
</pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              We can determine from these results that the <code class="literal">artist</code> property of <code class="literal">/music/album</code> is the "master" property and the <code class="literal">album</code> property of <code class="literal">/music/artist</code> is the "reverse" property. These names imply more of a hierarchy than is really necessary: both properties are real, and you can usually write MQL queries without knowing whether a property is "master" or "reverse". Another way of thinking about master versus reverse properties is to assign a directionality to links. We can say that the link between an artist and an album is directed from the album to the artist. That is, it is an outgoing link from the album object and an incoming link to the artist object.
            </p>
          </div>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="id2953396" name="id2953396"></a>3.4.5.5. Other Properties of Properties
                  </h4>
                </div>
              </div>
            </div>
            <p>
              The <code class="literal">enumeration</code> property of <code class="literal">/type/property</code> was explained in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#enumerations" title="3.3.5. Enumerations">Section 3.3.5</a>: it refers to the namespace within which the value of the property becomes a key:
            </p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Query
                    </th>
                    <th>
                      Result
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <pre class="programlisting">{
  "id":"/type/lang/iso639",
  "/type/property/enumeration":null
}
</pre>
                    </td>
                    <td>
                      <pre class="programlisting">{
  "id":"/type/lang/iso639",
  "/type/property/enumeration":"/lang"
}
</pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              When the <code class="literal">expected_type</code> of a property is a numeric value, such as <code class="literal">/type/float</code> or <code class="literal">/type/int</code>, the <code class="literal">unit</code> property of the property typically refers to a <code class="literal">/type/unit</code> object that provides an interpretation for the value. Consider the <code class="literal">/music/track/length</code> property:
            </p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Query
                    </th>
                    <th>
                      Result
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <pre class="programlisting">{
  "id":"/music/track/length",
  "type":"/type/property",
  "expected_type":null,
  "unit":null
}
</pre>
                    </td>
                    <td>
                      <pre class="programlisting">{
  "id" : "/music/track/length",
  "type":"/type/property",
  "expected_type":"/type/float",
  "unit":"/en/second"
}
</pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              The <code class="literal">links</code> property of a property is the set of <code class="literal">/type/link</code> links that the property represents. We'll learn more about links in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#links" title="3.7. Links, Reflection and History">Section 3.7</a>.
            </p>
          </div>
        </div>
      </div>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title">
                <a id="directives" name="directives"></a>3.5. MQL Directives
              </h2>
            </div>
          </div>
        </div>
        <p>
          Directives are special MQL commands that specify additional details about a query or request additional processing of query results. Because MQL is based on JSON, MQL directives look just like ordinary properties and values. The names of MQL directives are reserved words in MQL, however, and Metaweb does not allow types to define properties with these names.
        </p>
        <p>
          The sections that follow document the <code class="literal">limit</code>, <code class="literal">return</code>, <code class="literal">sort</code>, <code class="literal">index</code> and <code class="literal">optional</code> directives. MQL also supports a <code class="literal">link</code> directive, which is covered in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#links" title="3.7. Links, Reflection and History">Section 3.7</a>.
        </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="limitdirective" name="limitdirective"></a>3.5.1. Limiting Results
                </h3>
              </div>
            </div>
          </div>
          <p>
            To reduce resource consumption and bandwidth usage, Metaweb never returns more than 100 matches for a query (or for a sub-query) unless you explicitly ask for more. The Freebase database contains thousands of bands, for example, but this query only returns 100 of them:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null
}]
</pre>
          <p>
            To change the number of desired results to a larger, or a smaller, number, use the <code class="literal">limit</code> directive. Here, for example, is a query that returns the names of up to 2000 bands:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "limit":2000
}]
</pre>
          <p>
            Although MQL allows you to request arbitrarily large numbers of results, Metaweb does not guarantee that you'll always get an answer. Complicated queries with a large number of results may time out before Metaweb can complete the result. A better solution for large queries is to retrieve the results in batches, using a <span class="emphasis"><em>cursor</em></span>. Cursors are not part of MQL: instead they are part of the <span class="emphasis"><em>mqlread</em></span> service for delivering MQL queries to a Metaweb database. They are documented in <a class="xref" href="http://mql.freebaseapps.com/ch04.html#cursors" title="4.2.4.1. Fetching Large Result Sets with Cursors">Section 4.2.4.1</a>.
          </p>
          <p>
            Specifying a limit of 1 tells Metaweb that you're only interested in one result, and allows you to omit square brackets from your query. The following query, for example, is guaranteed not to result in a uniqueness error, even if there are two bands that have the same name:
          </p>
          <pre class="programlisting">{
  "type": "/music/artist",
  "name": "The Police",
  "id": null,
  "limit": 1
}
</pre>
          <p>
            Specifying a limit of 0 can be useful to prune the result tree of values you aren't really interested in. The following query, for example, asks "What are the names of three bands who have recorded the song <span class="emphasis"><em>Masters of War</em></span>? I'm only interested in the band name, so don't include the name of the song in the results":
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "track":{
    "name":"Masters of War",
    "limit":0
  },
  "limit":3
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : "Kevn Kinney",
  "track" : null
},{
  "type" : "/music/artist",
  "name" : "Timesbold",
  "track" : null
},{
  "type" : "/music/artist",
  "name" : "Bob Dylan",
  "track" : null
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Notice that the result of the query does not include a <code class="literal">limit</code> property. MQL responses normally have the same structure as their query, but most directives are not considered part of this structure and are not included in responses.
          </p>
          <p>
            Since the <code class="literal">limit</code> directive must appear within curly braces, limiting a query sometimes requires you to transform a simple query into a more complex one (with more complex results). Consider this query to list all albums by The Police:
          </p>
          <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : []
}
</pre>
          <p>
            If we want to limit the result to five albums, we must rewrite the query as follows:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : [{"name":null, "limit":5}]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : [
    {"name" : "Outlandos d'Amour"},
    {"name" : "Reggatta de Blanc"},
    {"name" : "Zenyatta Mondatta"},
    {"name" : "Ghost in the Machine"},
    {"name" : "Synchronicity"}
  ]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Finally, note that a limit of <code class="literal">n</code> means "return the first <code class="literal">n</code> results" not "pick <code class="literal">n</code> results at random". Results of Metaweb queries are unordered (unless you use the <code class="literal">sort</code> directive, which will be introduced shortly) so the results returned are effectively arbitrary. They are repeatable, however: re-running the same query will typically return the same <code class="literal">n</code> results.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="countingresults" name="countingresults"></a>3.5.2. Counting Results
                </h3>
              </div>
            </div>
          </div>
          <p>
            MQL supports three directives for counting or estimating the number of matches for a query. This section explains the <code class="literal">return</code>, <code class="literal">count</code>, and estimate-<code class="literal">count</code> directives.
          </p>
          <p>
            Sometimes you don't care <span class="emphasis"><em>what</em></span> the results of a query are: you just want to know <span class="emphasis"><em>how many</em></span> results there are. To find out, use the <code class="literal">return</code> directive. Here's how we'd ask how many albums The Police have released:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : { "return":"count" }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : 22
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The value of the <code class="literal">return</code> directive is <code class="literal">"count"</code>. Notice that this directive goes inside curly braces in the query, but the count is returned as a plain integer value. If we were interested in the names of the albums, we'd obviously have to use square brackets in the query so that Metaweb could return an array of results to us. In this case, the square brackets are unnecessary. (Though if we'd used them, Metaweb would return <code class="literal">[22]</code>.)
          </p>
          <p>
            If <code class="literal">return:count</code> appears at the top-level of a query, then Metaweb returns just the count:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "artist" : "The Police",
  "return":"count"
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">22
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Notice that in this case, the presence of the <code class="literal">return</code> directive causes the result to have a completely different JSON structure than the query does.
          </p>
          <p>
            If a top-level query finds no matches, it returns a count of 0. Let's ask how many albums named "Arrested" have been released by The Police:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "artist" : "The Police",
  "name" : "Arrested",
  "return":"count"
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">0
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Note, however, that we get a different result when we ask the question this way:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : {
    "name": "Arrested",
    "return":"count"
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">null
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The result of this query without the <code class="literal">return:count</code> directive is <code class="literal">null</code>: it does not match anything. So there is nothing to count, and the query returns <code class="literal">null</code> even with the directive. Adding an <code class="literal">optional</code> directive to the sub-query solves this problem. We'll learn about the <code class="literal">optional</code> directive in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#optionaldirective" title="3.5.5. Optional Matches">Section 3.5.5</a>.
          </p>
          <p>
            If your query is complex, or if there are many results, the request may timeout before Metaweb can count the exact number of matches. If timeouts are a concern, use <code class="literal">return:estimate-count</code> instead of <code class="literal">return:count</code>. As its name implies, this version of the directive returns an estimate of the number of matches rather than an exact count. The following query, for example, asks for the approximate number of musical artists in the database:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/artist",
  "return":"estimate-count"
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">354200
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            With a dataset this large, asking for an exact count with <code class="literal">return:count</code> is likely to result in a timeout.
          </p>
          <p>
            In some circumstances, you may want to ask for the results of a query (up to the explicit limit you specify or up to the implicit limit of 100 results) and also ask for a count or estimate of the total number of results available. You might want to do this, for example, if you were displaying the results in paged form and wanted to include a message of the form "Results 1-20 of 317" on the first page. (The trick to retrieving subsequent pages of results is to use a <span class="emphasis"><em>cursor</em></span>. This is explained in <a class="xref" href="http://mql.freebaseapps.com/ch04.html#cursors" title="4.2.4.1. Fetching Large Result Sets with Cursors">Section 4.2.4.1</a>).
          </p>
          <p>
            If you want to retrieve results and a count, use the <code class="literal">count:null</code> directive or the <code class="literal">estimate-count:null</code> directive instead of the <code class="literal">return</code> directive. For example, to ask for the names of tracks by The Police, and a count of the total number of tracks, you might use this query:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/track",
  "artist" : "The Police",
  "name" : null,
  "count" : null
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/track",
  "artist" : "The Police",
  "name" : "Can't Stand Losing You",
  "count" : 133
},{
  "type" : "/music/track",
  "artist" : "The Police",
  "name" : "Message in a Bottle",
  "count" : 133
},
// 98 more results omitted...
]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query returns 100 results, and the <code class="literal">count</code> property tells us that more results are available. Notice that the <code class="literal">count</code> property appears over and over again in each of the results. (Just as the <code class="literal">type</code> and <code class="literal">artist</code> properties do).
          </p>
          <p>
            We could also have used <code class="literal">estimate-count:null</code> in the query. In that case, each of the 100 results would have included <code class="literal">estimate-count:135</code>.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="sortdirective" name="sortdirective"></a>3.5.3. Sorting Results
                </h3>
              </div>
            </div>
          </div>
          <p>
            Use the <code class="literal">sort</code> directive if you'd like the Metaweb server to sort the results of your query before returning them. For example, to ask for the names of the tracks on an album in alphabetical order, sort them by name:
          </p>
          <pre class="programlisting">// Tracks on the album Synchronicity, in alphabetical order
{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track": [{
    "name":null,
    "sort":"name"
  }]
}
</pre>
          <p>
            As you can see, the <code class="literal">sort</code> directive simply specifies the name of the property by which the sort is to be done. To order these same tracks from shortest to longest, use "length" as the sort key:
          </p>
          <pre class="programlisting">// Tracks on the album Synchronicity, from shortest to longest
{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track": [{
    "name":null,
    "length":null,
    "sort":"length"
  }]
}
</pre>
          <p>
            Note that the query above includes <code class="literal">"length":null</code>. If you want to use a property as a sort key, you must query that property.
          </p>
          <p>
            To reverse this order, precede the name of the sort key by a minus sign:
          </p>
          <pre class="programlisting">// Tracks on the album Synchronicity, from longest to shortest
{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track": [{
    "name":null,
    "length":null,
    "sort":"-length"
  }]
}
</pre>
          <p>
            The sorts shown above are convenient, but could easily be duplicated on the client side. That is, you could request unordered results from Metaweb and sort them yourself. One situation in which the <code class="literal">sort</code> directive cannot be duplicated on the client is when it interacts with the <code class="literal">limit</code> directive. Result sets are truncated to the specified limit after the sort is applied. Use <code class="literal">sort</code> and <code class="literal">limit</code> together in queries like this:
          </p>
          <pre class="programlisting">// What is the longest track on Synchronicity?
{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track": {
    "name":null,
    "length":null,
    "sort":"-length",
    "limit":1
  }
}
</pre>
          <p>
            Sorting need not be limited to a single sort key. To specify more than one key, use an array on the right-hand side of the <code class="literal">sort</code> directive:
          </p>
          <pre class="programlisting">// List tracks by The Police, sorted from shortest to longest.
// Tracks of the same length should be in alphabetical order.
[{
  "type":"/music/track",
  "artist":"The Police",
  "name":null,
  "length":null,
  "sort":["length","name"]
}]
</pre>
          <p>
            If your query includes sub-queries, then the properties of those sub-queries can also be used as sort keys. The query below uses this kind of hierarchically-named sort key. Note also that it has two distinct sort clauses.
          </p>
          <pre class="programlisting">// List all albums by The Police, along with the name of their longest track.
// Order the albums from longest longest track to shortest longest track.
[{
  "type":"/music/album",
  "artist":"The Police",
  "name":null,
  "track":{
    "name":null,
    "length":null,
    "sort":"-length",
    "limit":1
  },
  "sort":"-track.length"
}]
</pre>
          <p>
            Finally, here is a complex example that uses multiple sort keys, hierarchically-named sort keys, and a sort key that includes a fully-qualified property name (see <a class="xref" href="http://mql.freebaseapps.com/ch03.html#fullpropertyids" title="3.4.1. Simple and Qualified Property Names">Section 3.4.1</a>):
          </p>
          <pre class="programlisting">// Return a list of performances (character/actor pairs) in George Lucas films.
// Sort them by character name. If the character appears in more than
// one film, sort by film name. If more than one actor portrays the character
// in a single film, sort them by actor birthdate (most to least recent).
[{
  "type":"/film/performance",
  "film":{
    "name":null,
    "directed_by":"George Lucas"
  },
  "character":null,
  "actor":{
     "name":null,
     "/people/person/date_of_birth":null
  },
  "sort":["character",
          "film.name",
          "-actor./people/person/date_of_birth"]        
}]
</pre>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="orderedcollections" name="orderedcollections"></a>3.5.4. Ordered Collections
                </h3>
              </div>
            </div>
          </div>
          <p>
            If you do not include a <code class="literal">sort</code> directive in a query then Metaweb makes not guarantees about the order in which results are returned. If you don't ask for the data to be sorted, you should treat the result as an unordered set of values rather than an ordered list. <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2954555" id="id2954555" name="id2954555">13</a>]</sup>
          </p>
          <p>
            Some data, such as the tracks on an album, have a natural order: the order in which they are arranged in the album. If you want results to be sorted according to this natural ordering, use <code class="literal">"sort":"index"</code>. (Or, to reverse the natural ordering, use <code class="literal">"sort":"-index"</code>.
          </p>
          <pre class="programlisting">// Return the tracks on the album Synchronicity in the order that they appear
{
  "type":"/music/album",
  "artist":"The Police",
  "name":"Synchronicity",
  "track":[{
    "name":null,
    "index":null,
    "sort":"index"
  }]
}
</pre>
          <p>
            Since we've used "index" as a sort key, we must query the value of "index" as well. <code class="literal">index</code> is a MQL directive that looks like a property, because it is queried with <code class="literal">null</code>, and because, unlike other directives, it is included in query results. When you include the <code class="literal">"index":null</code> directive in a query, the results include <code class="literal">index</code> properties whose values are the integers between 0 and <code class="literal">n</code>-1, where <code class="literal">n</code> is the number of ordered results. It is important to understand that indexes do not apply to objects in Metaweb, but to the relationships between objects. It is the link between the album "Synchronicity" and the track "Mother" that has an index of 3 (because it is the fourth song on the album), not the track itself. This becomes clear when you consider the case of a track that appears on more than one album: if "Mother" also appears on an album named "Greatest Hits" it is likely to have a different index on that album.
          </p>
          <p>
            <code class="literal">index</code> is a directive, not a property. MQL read queries may use <code class="literal">index</code> as a sort key, and they may query the index with <code class="literal">"index":null</code>, but may not use the keyword in any other way. You cannot write <code class="literal">"index":1</code> to ask for the second item in a set, for example. Similarly, <code class="literal">index</code> cannot be used with operators such as <code class="literal">&lt;</code> to select indexes less than a given value. (We'll learn about <code class="literal">&lt;</code> and other operators in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#operators" title="3.6. MQL Operators">Section 3.6</a>.) The <code class="literal">index</code> directive can be used in other ways in write queries, however, and we'll learn about that in <a class="xref" href="http://mql.freebaseapps.com/ch05.html" title="Chapter 5. The MQL Write Grammar">Chapter 5</a>.
          </p>
          <p>
            The index of a track on an album is an important and useful detail. And because a single track can appear on more than one album, it is not possible to capture this ordering with a property on the track object. It is for this reason that the <code class="literal">index</code> directive is useful here. But this is a somewhat unusual case, however, and links in Freebase do not typically have an order associated with them. Consider the set of albums by The Police instead of the set of tracks on Synchronicity. The most natural order for albums by a band is probably by release date. But this is captured by the <code class="literal">release_date</code> property of the album object, and there is no need to sort on <code class="literal">index</code> to obtain a chronological list of albums.
          </p>
          <p>
            While most Freebase data is unordered, bear in mind that some is partially ordered. Any time you use the <code class="literal">"index":null</code> directive, you should be prepared for returned indexes of <code class="literal">null</code> to be returned along with the numbered indexes. The <code class="literal">/film/film</code> and <code class="literal">/film/performance</code> types provide an example. The <code class="literal">starring</code> property of a film links to performance objects that specify the cast (the actors and the characters they portray) of the film. Indexes are sometimes used to capture the billing order of the top stars in the movie, while minor performances are left unordered.
          </p>
          <p>
            The <code class="literal">index</code> directive can be used in conjunction with the <code class="literal">sort</code> and <code class="literal">limit</code> directives. Consider the following query, which ask for the top two stars in the movie <span class="emphasis"><em>Psycho</em></span>:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/film/film",
  "name" : "Psycho",
  "directed_by":"Alfred Hitchcock",
  "starring" : [{
    "actor" : null,
    "character" : null,
    "index" : null,
    "sort" : "index",
    "limit" : 2
  }]
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/film/film",
  "name" : "Psycho",
  "directed_by" : "Alfred Hitchcock",
  "starring" : [{
    "actor" : "Anthony Perkins",
    "character" : "Norman Bates",
    "index" : 0
  },{
    "actor" : "Janet Leigh",
    "character" : "Marion Crane",
    "index" : 1
  }]
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="orderedcollectionrelative" name="orderedcollectionrelative"></a>3.5.4.1. Indexes are Relative
                  </h4>
                </div>
              </div>
            </div>
            <p>
              The query above correctly returns the names of the final two tracks on the album Synchronicity. Look carefully, however at the <code class="literal">index</code> values it returns: the last track is given an index of 1 and the penultimate track an index of 0. This is not a bug: this query simply reveals the true nature of ordered collections in Metaweb. Metaweb does not include an absolute index for each link. The implementation is able to say whether any link is greater-than or less-than another, but it cannot tell you the absolute position of that link within the complete set of links.
            </p>
            <p>
              The number that Metaweb returns as the value of the <code class="literal">index</code> property is a synthetic one, generated by Metaweb as a simple way to express the order of elements. If Metaweb returns an array holding <span class="emphasis"><em>n</em></span> indexed elements, then it generates <code class="literal">index</code> values for those elements that range from 0 to <span class="emphasis"><em>n</em></span>-1. (There may be additional elements in the array that have an <code class="literal">index</code> of <code class="literal">null</code>, however.) For example, if you ask for the last two tracks on an album, the resulting values have indexes 0 and 1. If you ask for tracks that are shorter than 2 minutes (we'll learn how to do this in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#operators" title="3.6. MQL Operators">Section 3.6</a>) and Metaweb finds three of them, then it will assign them index values of 0, 1, and 2. If you want to know the track number for the tracks on a particular album, you must query the complete set of tracks. Then add one to the <code class="literal">index</code> value to get the track number. If you want to know the track numbers of the short songs, you must query the complete set of tracks, and search for the short songs yourself.
            </p>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="optionaldirective" name="optionaldirective"></a>3.5.5. Optional Matches
                </h3>
              </div>
            </div>
          </div>
          <p>
            In addition to the <code class="literal">limit</code>, <code class="literal">return</code>, <code class="literal">sort</code> and <code class="literal">index</code> directives, MQL also includes an <code class="literal">optional</code> directive. If part of your query is not required to match, add <code class="literal">"optional":"optional"</code> to it. For example, we can use the <code class="literal">optional</code> directive to ask the question: "What bands have recorded the song "Masters of War", and do they have a Greatest Hits album?". The query looks like this:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "track" : "Masters of War",
  "album" : {
    "name" : "Greatest Hits",
    "optional" : "optional"
  }
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : "Kevn Kinney",
  "track" : "Masters of War",
  "album" : null
},
{
  "type" : "/music/artist",
  "name" : "Timesbold",
  "track" : "Masters of War",
  "album" : null
},
{
  "type" : "/music/artist",
  "name" : "Bob Dylan",
  "track" : "Masters of War",
  "album" : { "name" : "Greatest Hits" }
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Without the <code class="literal">optional</code> directive, the query would only return bands whose have recorded Masters of War <span class="emphasis"><em>and</em></span> have released a Greatest Hits album. With the optional directive, we get all bands who have recorded the song, and additionally, we find out whether or not they have released a Greatest Hits album.
          </p>
          <p>
            Optional queries can be nested inside optional queries. The following query is an extension to the one above. It further asks whether "Masters of War" appears on the Greatest Hits album. Without the nested <code class="literal">optional</code> directive, only Greatest Hits albums that include the song would be matched.
          </p>
          <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "track" : "Masters of War",
  "album" : {
    "name" : "Greatest Hits",
    "optional" : "optional",
    "track" : {
      "name" : "Masters of War",
      "optional" : "optional"
    }
  },
}]
</pre>
          <p>
            MQL allows <code class="literal">"optional":true</code> instead of <code class="literal">"optional":"optional"</code>. You can also write <code class="literal">"optional":"required"</code> or <code class="literal">"optional":false</code> to indicate that a match is required, but this is the default and is never necessary or useful.
          </p>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="id2955043" name="id2955043"></a>3.5.5.1. When to use the optional Directive
                  </h4>
                </div>
              </div>
            </div>
            <p>
              In order to understand when to use the <code class="literal">optional</code> directive, it is important to understand when a sub-query requires a match and when it does not. Suppose we want to ask for a list of artists who have recorded "Masters of War" and for the nicknames of those artists, if they have any:
            </p>
            <pre class="programlisting">[{
  "type" : "/music/artist",
  "track" : "Masters of War",
  "name" : null,
  "/common/topic/alias" : []
}]
</pre>
            <p>
              This request for aliases is implicitly optional: if an artist has no nicknames, <code class="literal">[]</code> will be returned. The same is true if we write <code class="literal">"/common/topic/alias":[{}]</code>. If none of the matching artists has more than one nickname, then we could even write <code class="literal">"/common/topic/alias":null</code>. In that case, each result would include either the single nickname or <code class="literal">null</code>. These queries simply ask for aliases, they do not constrain the query to match only artists that do have nicknames. Suppose, however that we're only interested in English nicknames:
            </p>
            <pre class="programlisting">[{
  "type" : "/music/artist",
  "track" : "Masters of War",
  "name" : null,
  "/common/topic/alias" : [{"value":null, "lang":"/lang/en"}]
}]
</pre>
            <p>
              We've now introduced a constraint into the sub-query, and only artists who have at least one English-language alias will match. Even though this alias sub-query is in square brackets, it still requires at least one match unless we add an <code class="literal">optional</code> directive:
            </p>
            <pre class="programlisting">[{
  "type" : "/music/artist",
  "track" : "Masters of War",
  "name" : null,
  "/common/topic/alias" : [{
    "optional":true,
    "value":null,
    "lang":"/lang/en"
  }]
}]
</pre>
            <p>
              The queries <code class="literal">[]</code> and <code class="literal">[{}]</code> do not require a match, but putting any property inside the curly braces transforms the sub-query into one that is required. This is true even if that property is a query rather than a constraint. So while <code class="literal">"/common/topic/alias":[]</code> will match objects that have no aliases, the same is not true of this query:
            </p>
            <pre class="programlisting">"/common/topic/alias":[{"value":null}]
</pre>
            <p>
              By explicitly stating our request for the value of each alias, we've transformed the query from one that is implicitly optional to one that requires at least one match.
            </p>
          </div>
          <div class="sect3" lang="en" xml:lang="en">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">
                    <a id="id2955152" name="id2955152"></a>3.5.5.2. Optional and return:count
                  </h4>
                </div>
              </div>
            </div>
            <p>
              Queries that use <code class="literal">return:count</code> can add <code class="literal">optional:true</code> so that they can return a count of zero instead of returning <code class="literal">null</code> to indicate a failure to find a match:
            </p>
            <div class="informaltable">
              <table border="1">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Query
                    </th>
                    <th>
                      Result
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : {
    "name": "Arrested",
    "return":"count",
    "optional":true
  }
}
</pre>
                    </td>
                    <td>
                      <pre class="programlisting">{
  "type" : "/music/artist",
  "name" : "The Police",
  "album" : 0
}
</pre>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>
              Without the <code class="literal">optional</code> directive, this query would return <code class="literal">null</code> because no match would be found at all. Note that using <code class="literal">optional</code> is only necessary in sub-queries: <code class="literal">return:count</code> at the toplevel returns 0 when no match is found.
            </p>
          </div>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2955245" name="id2955245"></a>3.5.6. Forbidden Matches
                </h3>
              </div>
            </div>
          </div>
          <p>
            The <code class="literal">optional</code> directive can be used in another important way. If we include <code class="literal">"optional":"forbidden"</code> in a sub-query, then the results will not include any values for which the sub-query matches. Here, for example, is how we find bands that have recorded "Masters of War" and have <span class="emphasis"><em>not</em></span> released a Greatest Hits album:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "track" : "Masters of War",
  "album" : {
    "name" : "Greatest Hits",
    "optional" : "forbidden"
  },
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : "Kevn Kinney",
  "track" : "Masters of War",
  "album" : null
},
{
  "type" : "/music/artist",
  "name" : "Timesbold",
  "track" : "Masters of War",
  "album" : null
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Note that if a sub-query includes <code class="literal">"optional":"forbidden"</code>, the response to that sub-query will always be <code class="literal">null</code>. Note also that there is no boolean alternative to the string "forbidden" – a value of <code class="literal">false</code> means "required", not "forbidden".
          </p>
          <p>
            A query can include multiple forbidden sub-queries. This query, for example, finds bands that have not released albums named "Greatest Hits" or "The Best Of":
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "neither:album":{"optional":"forbidden", "name":"Greatest Hits"},
  "nor:album":{"optional":"forbidden", "name":"The Best Of"}
}]
</pre>
          <p>
            When we use <code class="literal">null</code> in a MQL query, we're making a request for the value of a property, rather than constraining that property to have the value <code class="literal">null</code>. You can use <code class="literal">optional:forbidden</code> to write queries that constrain a property to be <code class="literal">null</code>. Suppose we wanted to ask Freebase for a list of bands that have no known albums (note that an <code class="literal">optional:forbidden</code> clause must always have another clause present, so <code class="literal">"id":null</code> has been included in the query):
          </p>
          <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "album" : { "optional" : "forbidden",
  "id" : null,
  }
}]
</pre>
          <p>
            MQL also supports a <code class="literal">!=</code> operator, which excludes results from a query in a different way. We'll learn about <code class="literal">!=</code> in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#butnotoperator" title="3.6.4. The " but="" not"="" operator="" !="&gt;Section 3.6.4&lt;/a&gt;.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=" sect1"="" lang="en" xml:lang="en">
        </a></p><div class="titlepage"><a class="xref" href="http://mql.freebaseapps.com/ch03.html#butnotoperator" title="3.6.4. The " but="" not"="" operator="" !="&gt;Section 3.6.4&lt;/a&gt;.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=" sect1"="" lang="en" xml:lang="en">
          </a><div><a class="xref" href="http://mql.freebaseapps.com/ch03.html#butnotoperator" title="3.6.4. The " but="" not"="" operator="" !="&gt;Section 3.6.4&lt;/a&gt;.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=" sect1"="" lang="en" xml:lang="en">
            </a><div><a class="xref" href="http://mql.freebaseapps.com/ch03.html#butnotoperator" title="3.6.4. The " but="" not"="" operator="" !="&gt;Section 3.6.4&lt;/a&gt;.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=" sect1"="" lang="en" xml:lang="en">
              </a><h2 class="title"><a class="xref" href="http://mql.freebaseapps.com/ch03.html#butnotoperator" title="3.6.4. The " but="" not"="" operator="" !="&gt;Section 3.6.4&lt;/a&gt;.
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=" sect1"="" lang="en" xml:lang="en">
                </a><a id="operators" name="operators"></a>3.6. MQL Operators
              </h2>
            </div>
          </div>
        </div>
        <p>
          A property in a MQL query that is not itself a query (i.e. one whose value is not <code class="literal">null</code> or <code class="literal">[]</code>) expresses a constraint. A normal property/value pair constrains results to objects for which that property is <span class="emphasis"><em>equal to</em></span> that value. But "equal to" is not the only constraint we can express in MQL. In this section we introduce <code class="literal">operators</code> such as <code class="literal">&lt;</code>, <span class="emphasis"><em>~=</em></span>, <span class="emphasis"><em>!=</em></span> and <span class="emphasis"><em>|=</em></span> which express constraints "less than", "matches", "not equal to", and "one of".
        </p>
        <p>
          If MQL was not based on JSON, these operators could naturally appear between a property name and its value. Since MQL uses JSON, however, operators are instead appended to a property name and appear inside the quotation marks. To express a "less than" constraint, for example, we might write:
        </p>
        <pre class="programlisting">"date_of_birth&lt;" : "2000"
</pre>
        <p>
          When a property name is followed by an operator, the value that follows must be a JSON literal (or, for the <code class="literal">|=</code> operator an JSON array): MQL sub-queries in curly braces are not allowed with operators. Finally, note that properties that include operators are like MQL directives and do not appear in the results of the query.
        </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="numericconstraints" name="numericconstraints"></a>3.6.1. Order Constraints
                </h3>
              </div>
            </div>
          </div>
          <p>
            We know how to ask "what are the names and lengths of the tracks on the album <span class="emphasis"><em>Synchronicity</em></span> by The Police?". The query looks like this:
          </p>
          <pre class="programlisting">{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track":[{"name":null, "length":null}]
}
</pre>
          <p>
            Metaweb also allows us to ask "What are the names and lengths of the <span class="emphasis"><em>long</em></span> songs on the album?" The query below includes a numeric constraint on the <code class="literal">length</code> property, and the <span class="emphasis"><em>freebase.com</em></span> response only includes the two songs on the album that are longer than 300 seconds:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track":[{
    "name":null,
    "length":null,
    "length&gt;":300
  }]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "type" : "/music/album",
  "name" : "Synchronicity",
  "artist" : "The Police",
  "track" : [{
    "name" : "Synchronicity II",
    "length" : 305.066
  }, {
    "name" : "Wrapped Around Your Finger",
    "length" : 313.733
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The line <code class="literal">"length&gt;":300</code> in the query expresses a constraint to Metaweb: it specifies that the track must be longer than 300 seconds. In addition to <code class="literal">&gt;</code>, you can also use <code class="literal">&lt;</code> for less-than, and <code class="literal">&lt;=</code> and <code class="literal">&gt;=</code> for less-than-or-equal and greater-than-or-equal. Note, however, that no spaces are allowed before or after these punctuation characters.
          </p>
          <p>
            Note that constraining the <code class="literal">length</code> property with <code class="literal">&gt;</code> does not automatically query the property. We must include a separate <code class="literal">"length":null</code> line in our query if we want to know the exact length of the returned tracks. Note that according to JSON syntax <code class="literal">length&gt;</code> is a different property than <code class="literal">length</code>, so there is no need to use a property prefix to distinguish the constraint from the query.
          </p>
          <p>
            You can include more than one numeric constraint on the same property, restricting the value to a range. Here's how we ask for songs that are at least three minutes long, but less than four:
          </p>
          <pre class="programlisting">{
  "type":"/music/album",
  "name":"Synchronicity",
  "artist":"The Police",
  "track":[{
    "name":null,
    "length&gt;=":180,
    "length&lt;":240
  }]
}
</pre>
          <p>
            Note that this query constrains the value of the <code class="literal">length</code> property, but does not ask Metaweb to return the exact value of the property.
          </p>
          <p>
            Numbers are not the only type that can be constrained with these operators. Here, for example, is a query that constrains a <code class="literal">/type/datetime</code> property to obtain a list of albums released in January 1999:
          </p>
          <pre class="programlisting">[{
   "type":"/music/album",
   "name":null,
   "artist":null,
   "release_date&gt;=":"1999-01-01",
   "release_date&lt;=":"1999-01-31"
}]
</pre>
          <p>
            When the <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, and <code class="literal">&gt;=</code> operators are used with strings, they compare in case-insensitive, Unicode-aware alphabetical order. For example, to find bands whose name begins with the letter A or B, use this query:
          </p>
          <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "name&gt;=" : "A",
  "name&lt;" : "C"
}]
</pre>
          <p>
            It is not legal to use any of these order operators with the <code class="literal">id</code> (or <code class="literal">guid</code>) property. Fully-qualified names and guids cannot be compared alphabetically or numerically.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="textconstraints" name="textconstraints"></a>3.6.2. Pattern Matching with the ~= Operator
                </h3>
              </div>
            </div>
          </div>
          <p>
            The MQL pattern matching operator <code class="literal">~=</code> tests a property to see if it contains a specified word or phrase. <sup>[<a class="footnote" href="http://mql.freebaseapps.com/ch03#ftn.id2955740" id="id2955740" name="id2955740">14</a>]</sup> To try this out, let's find some short songs about love:
          </p>
          <pre class="programlisting">[{
   "type":"/music/track",
   "artist":null,
   "name":null,
   "name~=":"love",
   "length":null,
   "length&lt;":120
}]
</pre>
          <p>
            Here's a query for songs about love recorded by bands whose name begins with "The":
          </p>
          <pre class="programlisting">[{
   "type":"/music/track",
   "artist":null,
   "artist~=":"^The",
   "name":null,
   "name~=":"love"
}]
</pre>
          <p>
            Results include <span class="emphasis"><em>Love Shack</em></span> by The B-52's and <span class="emphasis"><em>For Your Love</em></span> by The Yardbirds. Notice that the constraint on the <code class="literal">artist</code> property in the query above uses the <code class="literal">^</code> character to specify that the word The must appear at the beginning of the artist's name. (This is like the anchor syntax used in regular expressions, but note that MQL patterns are not nearly as general as regular expressions.)
          </p>
          <p>
            Here's a query to find all bands whose name is two words long and begins with the word The (such as The Police and The Clash).
          </p>
          <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "name~=" : "^The *$"
}]
</pre>
          <p>
            This query is interesting in several ways. First, it uses <code class="literal">^</code> again to anchor the match to the beginning of the string. And it uses <code class="literal">$</code> to anchor to the end of the string. The <code class="literal">*</code> character matches any string of characters (other than spaces).
          </p>
          <p>
            <a class="xref" href="http://mql.freebaseapps.com/ch03.html#matchsyntax" title="Table 3.2. MQL Pattern Matching Syntax">Table 3.2</a> summarizes MQL pattern matching syntax.
          </p>
          <div class="table">
            <a id="matchsyntax" name="matchsyntax"></a>
            <p class="title">
              <b>Table 3.2. MQL Pattern Matching Syntax</b>
            </p>
            <div class="table-contents">
              <table border="1" summary="MQL Pattern Matching Syntax">
                <colgroup>
                  <col>
                  <col>
                </colgroup>
                <thead>
                  <tr>
                    <th>
                      Pattern
                    </th>
                    <th>
                      Matches
                    </th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <code class="literal">love</code>
                    </td>
                    <td>
                      <p>
                        Matches any string that contains the word "love". Does not match strings containing "glove" or "lover".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">love you</code>
                    </td>
                    <td>
                      <p>
                        Matches any string that contains the exact phrase "love you", such as "Hello, I Love You" but not "All You Need is Love".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">love*</code>
                    </td>
                    <td>
                      <p>
                        Matches any string containing a word that begins with "love", such as "love", "lover" or "lovely". Does not match "glove".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">*love</code>
                    </td>
                    <td>
                      <p>
                        Matches any string containing a word that ends with "love", such as "love" or "glove".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">*love*</code>
                    </td>
                    <td>
                      <p>
                        Matches any string that contains "love", such as "love", "glove", "lover" and "glover".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">^</code>
                    </td>
                    <td>
                      <p>
                        Matches the beginning of a string. For example, <code class="literal">^the</code> matches any string that begins with the word "the", and <code class="literal">^the*</code> matches any string that begins with a word that begins with "the", such as "they" or "there".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">$</code>
                    </td>
                    <td>
                      <p>
                        Matches the end of a string. For example, <code class="literal">hits$</code> matches any string that ends with the word "hits", and <code class="literal">*love$</code> matches "Sunshine of your Love" and "Smell the Glove".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">*</code>
                    </td>
                    <td>
                      <p>
                        Matches a single word. <code class="literal">^*$</code>, matches any single-word string, for example, and <code class="literal">I * you</code> matches any string that contains a 3-word phrase beginning with "I" and ending with "you".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">-</code>
                    </td>
                    <td>
                      <p>
                        A hyphen or other punctuation matches an optional space. For example, <code class="literal">bi-directional</code> matches "bi directional", "bi-directional", or "bidirectional".
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <code class="literal">\</code>
                    </td>
                    <td>
                      <p>
                        Use a backslash to escape any punctuation character that you want to match literally. <code class="literal">bi\-directional</code> matches any string that contains the hyphenated word "bi-directional", for example. Note, however, that JSON string literals require backslashes like this to be doubled. If you type a JSON query "by hand" or use string manipulation techniques to create a query, be sure to double the backslashes. If you use a JSON serializer to create the query, it should double the backslashes for you.
                      </p>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <span class="emphasis"><em>numbers</em></span>
                    </td>
                    <td>
                      <p>
                        When the pattern to be matched looks like a number, any numbers in the text that is being matched are first converted to normalized form. This means that leading zeros are removed, trailing zeros after the decimal point are removed, a zero is added before the decimal point if there is no digit there, and so on. If the match against the normalized text does not succeed, it is tried again with the numbers in their original, unnormalized form. This means that the pattern "7" matches "Agent 007", "July 07, 2008", and "7.0". But the pattern "007" does not match "7", "07", or "7.0".
                      </p>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div><br class="table-break">
          <p>
            Here's another example: what bands have three-word names that begin with "the" and end with a plural (e.g. The Beach Boys, The Doobie Brothers)?
          </p>
          <pre class="programlisting">[{
  "type" : "/music/artist",
  "name" : null,
  "name~=" : "^The * *s$"
}]
</pre>
          <p>
            Note that when a pattern includes multiple words (or even a word and an asterisk), Metaweb doesn't just attempt to match each word individually: it looks for a matching phrase. The pattern "I love" only matches strings that contain those two words in that order. It does not match "I want your love", for example. If you want to match any string that contains the words "I" and "love", regardless of order, you should use two separate properties:
          </p>
          <pre class="programlisting">[{
   "type":"/music/track",
   "name":null,
   "a:name~=":"I",
   "b:name~=":"love"
}]
</pre>
          <p>
            Here are two final notes about MQL pattern matching. First, all searches are case-insensitive. Second, it is not legal to perform pattern matching on the <code class="literal">id</code> (or <code class="literal">guid</code>) property.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="oneofoperator" name="oneofoperator"></a>3.6.3. The "one of" Operator |=
                </h3>
              </div>
            </div>
          </div>
          <p>
            MQL uses the <code class="literal">|=</code> operator to restrict the value of a property to a set of possible values, which are expressed as a JSON array of JSON literals. The constraint says "match any one of the values in this array". Here's how we can find a list of bands who have recorded an album named "Greatest Hits" or an album named "Super Hits":
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album|=":["Greatest Hits","Super Hits"],
  "album":[]
}]
</pre>
          <p>
            The <code class="literal">album</code> property in the response will include one or more album names, but the names will all be either "Greatest Hits" or "Super Hits".
          </p>
          <p>
            The values in the array can be numbers instead of strings. Here's how we look up the names of the first three chemical elements:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type":"/chemistry/chemical_element",
  "name":null,
  "atomic_number|=":[1,2,3],
  "atomic_number":null,
  "sort":"atomic_number"
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/chemistry/chemical_element",
  "name" : "Hydrogen",
  "atomic_number" : 1
},{
  "type" : "/chemistry/chemical_element",
  "name" : "Helium",
  "atomic_number" : 2
},{
  "type" : "/chemistry/chemical_element",
  "name" : "Lithium",
  "atomic_number" : 3
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Unlike the order and pattern-matching operators, the <code class="literal">|=</code> operator can be used on the <code class="literal">id</code> property, and this is a useful way to run the same query over multiple objects specified by id. The following query asks for the properties of three types, for example:
          </p>
          <pre class="programlisting">[{
  "id|=":["/type/type", "/type/property", "/type/key"],
  "id":null,
  "/type/type/properties":[]
}]
</pre>
          <p>
            Finally, here is an example that uses the <code class="literal">|=</code> constraint in two different places. It asks for the French and Spanish translations of the countries named "England" and "France"
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "type":"/location/country",
  "english:name|=": ["England",
                     "France"],
  "english:name": null,
  "foreign:name": [{
    "value":null,
    "lang":null,
    "lang|=":["/lang/fr",
              "/lang/es"]
  }]
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "type" : "/location/country",
  "english:name" : "England",
  "foreign:name" : [
    {"lang" : "/lang/fr", "value" : "Angleterre"},
    {"lang" : "/lang/es", "value" : "Inglaterra"}
  ]
},{
  "type" : "/location/country",
  "english:name" : "France",
  "foreign:name" : [
    {"lang" : "/lang/fr",  "value" : "France"},
    {"lang" : "/lang/es",  "value" : "Francia"}
  ]
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Most MQL operators expect a single JSON literal as their value. The <code class="literal">|=</code> operator instead expects a JSON array of JSON literals. Only literals are allowed in the array: the following query, for example, is <span class="emphasis"><em>not</em></span> legal:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album|=":[
    {"name":"Greatest Hits", "lang":"/lang/en"},   // Invalid MQL!
    {"name":"Super Hits", "lang":"/lang/en"}
  ],
  "album":[]
}]
</pre>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="butnotoperator" name="butnotoperator"></a>3.6.4. The "but not" Operator !=
                </h3>
              </div>
            </div>
          </div>
          <p>
            The <code class="literal">!=</code> operator says that the constrained property can be <span class="emphasis"><em>anything but</em></span> the specified value. (It does require that the property be <span class="emphasis"><em>something</em></span>, however: it does not match object for which the property is <code class="literal">null</code>.) Here, for example is how we list albums by The Police, but not Greatest Hits:
          </p>
          <pre class="programlisting">{
  "type":"/music/artist",
  "name":"The Police",
  "album":[{
    "name":null,
    "name!=":"Greatest Hits"
  }]
}
</pre>
          <p>
            And here we use <code class="literal">!=</code> to list the names of chemical elements other than elements 1, 2, and 3:
          </p>
          <pre class="programlisting">[{
  "type":"/chemistry/chemical_element",
  "name":null,
  "atomic_number!=":1,
  "a:atomic_number!=":2,
  "b:atomic_number!=":3
}]
</pre>
          <p>
            The <code class="literal">!=</code> operator is like the <code class="literal">optional:forbidden</code> directive in that it excludes values from the results. The operator and the directive are quite different, however, and it is important to understand when to use each. Contrast the album query above that uses <code class="literal">!=</code> with the following query, which uses <code class="literal">optional:forbidden</code> to say "list albums by The Police, excluding any that contain the song Roxanne":
          </p>
          <pre class="programlisting">{
  "type":"/music/artist",
  "name":"The Police",
  "album":[{
    "name":null,
    "track":{
      "name":"Roxanne",
      "optional":"forbidden"
    }
  }]
}
</pre>
          <p>
            The <code class="literal">!=</code> operator excludes a single JSON literal and is useful with unique properties, like <code class="literal">atomic_number</code> and <code class="literal">name</code> (which behaves like a unique property even though it technically isn't). The <code class="literal">optional:forbidden</code> directive, on the other hand, excludes any match of the sub-query that contains it. It works with non-unique properties and expresses the idea <span class="emphasis"><em>may not include</em></span>.
          </p>
          <p>
            The query with which we began this section can be simplified as follows:
          </p>
          <pre class="programlisting">{
  "type":"/music/artist",
  "name":"The Police",
  "album":[],
  "album!=":"Greatest Hits"
}
</pre>
          <p>
            This makes the query more difficult to understand, however. It appears as if the <code class="literal">!=</code> operator is constraining the non-unique property <code class="literal">album</code>. In fact, however, it is expressing a constraint on the default <code class="literal">name</code> property of any albums.
          </p>
          <p>
            It is important to understand that when you use <code class="literal">!=</code> on a property you are implicitly constraining the results to objects for which that property exists and has a value different than the one you specify. Even though a property value of <code class="literal">null</code> is different than the one you specify, it is not matched. Consider the following three queries, for example:
          </p>
          <pre class="programlisting">// How many albums have The Police released?
{
  "return":"count",
  "type":"/music/album",
  "artist":"The Police",
}
// How many live albums have they released?
{
  "return":"count",
  "type":"/music/album",
  "artist":"The Police",
  "release_type":"Live Album"
}
// How many non-live albums have they released?
{
  "return":"count",
  "type":"/music/album",
  "artist":"The Police",
  "release_type!=":"Live Album"
}
</pre>
          <p>
            The first query returns a count of 22, and you might expect that since every album is either a live not live the sum of the counts of the second and third queries would be 22. But, in fact, the second query returns 3 and the third returns 8. There are 8 Police albums that have a defined <code class="literal">release_type</code> whose value is something other than "Live Album". The other 11 Police albums do not have a <code class="literal">release_type</code> defined in Freebase (or did not when this was written). It turns out that <code class="literal">optional:forbidden</code> is what we want here. This query returns the 19 albums we expected:
          </p>
          <pre class="programlisting">{
  "return":"count",
  "type":"/music/album",
  "artist":"The Police",
  "release_type" : {"optional":"forbidden", "name":"Live Album"}
}
</pre>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2956557" name="id2956557"></a>3.6.5. Expressing AND, OR, and NOT in MQL
                </h3>
              </div>
            </div>
          </div>
          <p>
            We conclude this section on MQL operators with a discussion of Boolean operations in MQL queries. Boolean AND is the default operation in MQL: each of the properties in a MQL query expresses a constraint, and these constraints are implicitly ANDed together. Consider:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "name~=":"^The",
  "album":"Greatest Hits"
}]
</pre>
          <p>
            This query says: tell me the names of objects which have type "/music/artist" AND which have a name that begins with "The" AND which have an album named "Greatest Hits".
          </p>
          <p>
            The ability to use property prefixes in MQL allows us to express an AND on the value of a single property, as in the following query which asks "What are the names of objects that are both musical artists AND people AND have recorded a Christmas album?":
          </p>
          <pre class="programlisting">[{
  "name":null,
  "type":"/music/artist",
  "and:type":"/people/person",
  "album~=":"Christmas"
}]
</pre>
          <p>
            The <code class="literal">|=</code> operator was introduced as the "one of" operator, but note that we could also have called it the "OR" operator, as in the following query, which asks "Return the names of albums recorded by The Police OR Sting"
          </p>
          <pre class="programlisting">[{
  "type":"/music/album",
  "name":null,
  "artist|=":["The Police","Sting"]
}]
</pre>
          <p>
            Note that <code class="literal">|=</code> is a specialized operator, and expresses OR in a much less general way than the implicit AND of MQL. First of all, <code class="literal">|=</code> applies to only one property: it is not possible to request a list of albums released before 1990 or with genre "alternative rock". To obtain such a list, you must simply make two queries and combine the results. (It is possible to send two distinct queries in a single HTTP request. We'll learn how to do this in <a class="xref" href="http://mql.freebaseapps.com/ch04.html" title="Chapter 4. Metaweb Read Services">Chapter 4</a>.)
          </p>
          <p>
            MQL provides two distinct ways to express a Boolean NOT in a query. The <code class="literal">!=</code> operator says that a property must be <span class="emphasis"><em>anything but</em></span> the specified value. The <code class="literal">optional:forbidden</code> directive instead specifies that the set of values for a property <span class="emphasis"><em>may not include</em></span> an object that matches the sub-query of which it is a part. The distinction is subtle and it is important to understand when to each form of NOT, so we'll repeat some previously-seen examples.
          </p>
          <p>
            First, here is how you can use <code class="literal">!=</code> to say "list the albums by The Police but NOT Greatest Hits":
          </p>
          <pre class="programlisting">{
  "type":"/music/artist",
  "name":"The Police",
  "album":[{
    "name":null,
    "name!=":"Greatest Hits"
  }]
}
</pre>
          <p>
            Contrast that with the following query which asks for a list of bands that do NOT have a Greatest Hits album:
          </p>
          <pre class="programlisting">[{
  "type":"/music/artist",
  "name":null,
  "album":{
    "optional":"forbidden",
    "name":"Greatest Hits"
  }
}]
</pre>
          <p>
            Let's conclude with an example that combines AND, OR, and NOT into a single query:
          </p>
          <pre class="programlisting">[{
  "type" : "/music/album",
  "name" : null,
  "name!=" : "Greatest Hits",
  "release_date|=" : ["1978","1979"],
  "a:genre" : "New Wave",
  "b:genre|=" : ["Punk Rock", "Post-punk"]
  "artist" : {
    "name" : null,
    "type" : {
      "id" : "/people/person",
      "optional" : "forbidden"
    }
  },
}]
</pre>
          <p>
            This query asks for the names of albums which:
          </p>
          <div class="itemizedlist">
            <ul>
              <li>
                <p>
                  are NOT named "Greatest Hits" AND
                </p>
              </li>
              <li>
                <p>
                  were released in 1978 OR 1979 AND
                </p>
              </li>
              <li>
                <p>
                  have a genre of "New Wave" AND
                </p>
              </li>
              <li>
                <p>
                  also have a genre of either "Punk Rock" OR "Post-punk" AND
                </p>
              </li>
              <li>
                <p>
                  were recorded by an musical artist who is NOT a person (i.e. by a band and not a solo artist).
                </p>
              </li>
            </ul>
          </div>
          <p>
            Results include "Outlandos d'Amour" by The Police and "Go 2" by XTC.
          </p>
        </div>
      </div>
      <div class="sect1" lang="en" xml:lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title">
                <a id="links" name="links"></a>3.7. Links, Reflection and History
              </h2>
            </div>
          </div>
        </div>
        <p>
          This section of the chapter covers three related advanced features of MQL. The <code class="literal">link</code> directive and the type <code class="literal">/type/link</code> enable us to write MQL queries that return details about the links between objects rather than about the objects themselves. The first related feature is <span class="emphasis"><em>reflection</em></span>. Reflection allows us to ask for all links to or from an object. It is something like MQL wildcards, but is link-based rather than type-based. The second advanced feature related to links is history. Metaweb databases are journal-based and retain a record of every link ever made, even after those links are deleted or replaced. It is possible, therefore, to use properties of <code class="literal">/type/link</code> to query the modification history of any Metaweb object.
        </p>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2956797" name="id2956797"></a>3.7.1. Links to Sub-queries
                </h3>
              </div>
            </div>
          </div>
          <p>
            Here's a query that we come back to time and again in this chapter. It asks for details about the album Synchronicity by The Police:
          </p>
          <pre class="programlisting">{
  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "track":[]
  }
}
</pre>
          <p>
            Instead of asking about the tracks on the album, let's now ask for details on the link between the band and the album:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "link" : {}
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "link" : {
      "type" : "/type/link",
      "master_property" : "/music/album/artist",
      "reverse" : true
    }
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            There are many points to note about this query and its results. We'll start by saying that <code class="literal">link</code> is a MQL directive, not an object property. A <code class="literal">link</code> directive requests information about the link between the object (the album in this case) that matches the query that the directive appears in and the object (the band) that matches the parent query. The <code class="literal">link</code> directive can only appear in a nested query – it makes no sense in a toplevel query. (Toplevel link queries require a different syntax, explained below.)
          </p>
          <p>
            When we query a Metaweb object with <code class="literal">{}</code>, we get back the name, type, and id of the object. When we query a primitive with <code class="literal">{}</code>, we get back the type and value of the primitive (and also the <code class="literal">lang</code> and <code class="literal">namespace</code> properties of <code class="literal">/type/text</code> and <code class="literal">/type/key</code>). The results of the query above demonstrate that links are neither objects nor primitive values: they are something completely different. A link represents a relationship between two objects, it is not an object itself. Nor is it a primitive value: it carries too much information to be a simple primitive. Links do not have names, ids, or guids. Metaweb reports the type of a link as <code class="literal">/type/link</code>, but this is a synthetic type (like <code class="literal">/type/object</code>) that simply serves as a collection of properties: actual Metaweb objects are never assigned this type.
          </p>
          <p>
            In addition to noting the absence of the <code class="literal">name</code> and <code class="literal">id</code> properties in the link results above, let's consider the <code class="literal">master_property</code> and <code class="literal">reverse</code> properties. The <code class="literal">master_property</code> property of a link identifies the fully-qualified name of the master property that connects the two objects. In this case we learn than the band The Police and the album Synchronicity are connected through the <code class="literal">/music/album/artist</code> property. The <code class="literal">reverse</code> property of the link tells us whether the link was followed forward or "in reverse". In this case, <code class="literal">reverse</code> is <code class="literal">true</code>, because we started with the band and followed the property <code class="literal">/music/artist/album</code> to the album. Recall that <code class="literal">/music/artist/album</code> is the reciprocal of <code class="literal">/music/album/artist</code>.
          </p>
          <p>
            Links are different from objects and primitives in another way, too. The default property of a link is not <code class="literal">name</code>, <code class="literal">id</code>, or <code class="literal">value</code>. Instead, when we query a link using <code class="literal">"link":null</code>, it is the <code class="literal">master_property</code> of the link that is returned:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "link" : null
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "link" : "/music/album/artist"
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The <code class="literal">master_property</code> and <code class="literal">reverse</code> properties of a link aren't terribly useful in queries like these, since the very structure of the query shows us the property that is being followed. They are useful in a different style of link query (shown below), however, and are also useful with reflective queries (explained later in this section). Links do have properties other than <code class="literal">master_property</code> and <code class="literal">reverse</code>, however, and we can use a wildcard to discover them:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "link" : { "*" : null}
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "/music/artist/album" : {
    "name" : "Synchronicity",
    "link" : {
      "type" : "/type/link",
      "master_property" : "/music/album/artist",
      "reverse" : true,
      "source" : "Synchronicity",
      "target" : "The Police",
      "target_value" : null,
      "operation" : "insert",
      "valid" : true,
      "timestamp" : "2006-12-10T12:23:59.0685Z",
      "creator" : "/user/mwcl_musicbrainz"
    }
  }

}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The results of this query show a number of link properties. We've already seen <code class="literal">type</code>, <code class="literal">master_property</code> and <code class="literal">reverse</code>. <code class="literal">source</code> and <code class="literal">target</code> refer to the source and target of the link. Since we queried them here with a <code class="literal">"*":null</code> wildcard, we get the names of the source and target objects, rather than the objects themselves. If the target had been a primitive value (such as a name instead of an album), then the <code class="literal">target_value</code> property would have held the value of that primitive. (If the target is of <code class="literal">/type/text</code>, then the <code class="literal">target</code> property is the language of the text. If the target is of <code class="literal">/type/key</code>, then the <code class="literal">target</code> property is the namespace of the key.)
          </p>
          <p>
            The <code class="literal">valid</code> and <code class="literal">operation</code> properties of a link specify the current validity of the link and the operation (such as insertion or deletion) that was performed on it. They are used when querying the history of a link, and are explained in <a class="xref" href="http://mql.freebaseapps.com/ch03.html#history" title="3.7.4. History">Section 3.7.4</a>. For now you just need to know that if you omit these properties from your link queries, Metaweb will only return links that <span class="emphasis"><em>are</em></span> currently valid.
          </p>
          <p>
            The <code class="literal">timestamp</code> and <code class="literal">creator</code> properties are like those defined by <code class="literal">/type/object</code> but they specify the creator and creation time for the link rather than for either of the two linked objects. Here is a query, for example, that asks about the creation (when and by who) of the objects that represent The Police, their album Synchronicity and of the link between those two objects:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/the_police",
  "timestamp":null,
  "creator":null,
  "/music/artist/album": {
    "name":"Synchronicity",
    "timestamp":null,
    "creator":null,
    "link": {
      "timestamp":null,
      "creator":null,
    }
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/the_police",
  "timestamp":"2006-10-22T10:02:03.0012Z",
  "creator":"/user/metaweb",
  "/music/artist/album": {
    "name":"Synchronicity",
    "timestamp":"2006-12-10T12:23:59.0119Z",
    "creator":"/user/mwcl_musicbrainz",
    "link": {
      "timestamp":"2006-12-10T12:23:59.0685Z",
      "creator":"/user/mwcl_musicbrainz"
    }
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Here's another link query that demonstrates the <code class="literal">/type/link/creator</code> property as well as <code class="literal">/type/link/target_value</code>. It asks: "what is the name of the country Spain in French, and what Metaweb user contributed the translation?":
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/spain",
  "name" : {
    "link" : {
      "target" : "French",
      "target_value" : null,
      "creator" : null
    }
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/spain",
  "name" : {
    "link" : {
      "target" : "French",
      "target_value" : "Espagne",
      "creator" : "/user/mwcl_wikipedia_en"
    }
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The link object described in the response represents a link between a <code class="literal">/location/country</code> object and a <code class="literal">/type/text</code> value. Since <code class="literal">/type/text</code> is a primitive, the <code class="literal">target_value</code> property holds the <code class="literal">value</code> of the primitive – the text itself. Since the target is of <code class="literal">/type/text</code>, the <code class="literal">target</code> property represents the language of the text, and we use this fact in the query to specify that we're interested in the French version of the name. It is worth noting that we specify the language by name here, rather than by id with <code class="literal">/lang/fr</code> as we usually do. The reason is that the <code class="literal">/type/link/target</code> property has an expected type of <code class="literal">/type/object</code> (since it can represent any object). The default property of <code class="literal">/type/lang</code> is <code class="literal">id</code>, which is why we normally specify languages by id. But in this case, it is the default property of <code class="literal">/type/object</code> that matters, which is why we must specify the name of the desired language rather than its id. (We could also have written <code class="literal">"target":{"id":"/lang/fr"}</code>
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="id2957426" name="id2957426"></a>3.7.2. Toplevel Links
                </h3>
              </div>
            </div>
          </div>
          <p>
            We saw above that the <code class="literal">link</code> directive allows us to query the link between the object or value that matches a sub-query and the object that matches its parent query. We can't use the <code class="literal">link</code> directive in a toplevel query, however. If you want to write a toplevel link query you must take a different, but simple, approach. Just include this constraint in your query:
          </p>
          <pre class="programlisting">"type":"/type/link"
</pre>
          <p>
            <code class="literal">/type/link</code> is not a real type and no Metaweb objects have this type. But putting the line above into a MQL query tells Metaweb that you're interested in links rather than objects. When you write link queries of this sort, the <code class="literal">source</code> and <code class="literal">target</code> properties of <code class="literal">/type/link</code> typically become important to either constrain or query the source and destination of the link. (But note that you must write <code class="literal">"type":"/type/link"</code> in order to use the <code class="literal">source</code> and <code class="literal">target</code> properties: MQL does not allow you to use fully-qualified names for link properties, so you cannot omit the type specification and just query <code class="literal">/type/link/target</code> and <code class="literal">/type/link/source</code>.)
          </p>
          <p>
            Here is how we query all outgoing links from The Police, asking for the name of the property that represents the link and primitive value or the name, type and id of the object or value at the other end of the link.
          </p>
          <pre class="programlisting">[{
  "type" : "/type/link",
  "source" : {
    "id" : "/en/the_police"
  },
  "master_property" : null,
  "target" : {},
  "target_value" : null
}]
</pre>
          <p>
            And here is how we ask instead for the name, type, and id of all objects that are linked to The Police:
          </p>
          <pre class="programlisting">[{
  "type" : "/type/link",
  "target" : {
    "id" : "/en/the_police"
  },
  "master_property" : null,
  "source" : {}
}]
</pre>
          <p>
            We can also query links to primitive values. The following query, for example, asks for objects that are linked to the date July 4th, 1776:
          </p>
          <pre class="programlisting">[{
  "type" : "/type/link",
  "target_value" : {
    "type" : "/type/datetime",
    "value" : "1776-07-04"
  },
  "master_property" : null,
  "source" : {}
}]
</pre>
          <p>
            Toplevel link queries can be used in conjunction with <code class="literal">return:count</code>. This query asks: "how many links did the user "wp_typer" create to type objects as <code class="literal">/music/artist</code>?":
          </p>
          <pre class="programlisting">{
  "return" : "count",
  "type" : "/type/link",
  "creator" : "/user/wp_typer",
  "master_property" : "/type/object/type",
  "target" : {
    "id" : "/music/artist"
  }
}
</pre>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="reflection" name="reflection"></a>3.7.3. Reflection
                </h3>
              </div>
            </div>
          </div>
          <p>
            Reflection is a MQL feature that is closely related to links. It is a mechanism for querying the properties of an object, regardless of the type that defines those properties. The <code class="literal">*</code> wildcard described earlier in this chapter is a type-based wildcard: it queries the value of all properties defined by a type, plus the common properties defined by <code class="literal">/type/object</code>. Reflection is different: it is a link-based wildcard mechanism that queries the outgoing or incoming links of an object, regardless of the type associated with those links.
          </p>
          <p>
            Reflection is done with <code class="literal">/type/reflect</code>. Like <code class="literal">/type/link</code>, <code class="literal">/type/reflect</code> is a pseudo-type and objects are never assigned this type. <code class="literal">/type/reflect</code> exists simply to serve as a holder for three special properties: <code class="literal">/type/reflect/any_master</code>, <code class="literal">/type/reflect/any_reverse</code>, and <code class="literal">/type/reflect/any_value</code>. These properties must always be used by their fully-qualified names. The word "any" in these property names indicates their wildcard behavior. <code class="literal">/type/reflect/any_master</code> matches any outgoing link to another object. <code class="literal">/type/reflect/any_reverse</code> matches any incoming link from another object. And <code class="literal">/type/reflect/any_value</code> matches any link to a primitive value such as <code class="literal">/type/text</code>, <code class="literal">/type/datetime</code> or <code class="literal">/type/float</code>.
          </p>
          <p>
            The following query uses all three of these properties on The Police. The results shown are dramatically pruned to fit. Note that each of the sub-queries uses the <code class="literal">link</code> directive to ask for the name of the property that was matched (recall that the default property of links is <code class="literal">master_property</code>):
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id":"/en/the_police",
  "/type/reflect/any_master":[{
    "link":null,
    "name":null
  }],
  "/type/reflect/any_reverse":[{
    "link":null,
    "name":null
  }],
  "/type/reflect/any_value":[{
    "link":null,
    "value":null
  }]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/en/the_police",
  "/type/reflect/any_master" : [{
    "link" : "/type/object/type",
    "name" : "Musical Artist"
  },{
    "link" : "/music/artist/genre",
    "name" : "Rock music"
  },{
    "link" : "/music/artist/origin",
    "name" : "London"
  },{
    "link" : "/common/topic/webpage",
    "name" : null
  },{
    "link" : "/music/artist/label",
    "name" : "Polydor Records"
  }],
  "/type/reflect/any_reverse" : [{
    "link" : "/music/album/artist",
    "name" : "Outlandos d'Amour"
  },{
    "link" : "/music/album/artist",
    "name" : "Reggatta de Blanc"
  },{
    "link" : "/music/track/artist",
    "name" : "Message in a Bottle"
  },{
    "link" : "/music/track/artist",
    "name" : "Can't Stand Losing You"
  }],
  "/type/reflect/any_value" : [{
    "link" : "/type/object/name",
    "value" : "The Police"
  },{
    "link" : "/common/topic/alias",
    "value" : "Police"
  },{
    "link" : "/music/artist/active_start",
    "value" : "1977-01"
  },{
    "link" : "/music/artist/active_end",
    "value" : "1986-06"
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            Note that the <code class="literal">/type/reflect/any_value</code> does not actually return every value of an object. The <code class="literal">id</code>, <code class="literal">key</code>, <code class="literal">timestamp</code> and <code class="literal">creator</code> properties are not matched by <code class="literal">/type/reflect/any_value</code>. Since every object has values for these properties, however, it is easy to write queries that ask for them explicitly. Furthermore, <code class="literal">/type/reflect/any_value</code> never matches <span class="emphasis"><em>any</em></span> property whose value is a <code class="literal">/type/id</code> or a <code class="literal">/type/key</code>. In particular, this means that an <code class="literal">any_value</code> query on a namespace object will not match the <code class="literal">/type/namespace/keys</code> properties that identify the names in the namespace.
          </p>
          <p>
            Another difficulty with <code class="literal">/type/reflect/any_value</code> is that it is tricky to ask for the <code class="literal">lang</code> property of text values. The expected type of <code class="literal">any_value</code> is <code class="literal">/type/value</code> which does not have a <code class="literal">lang</code> property. This means that you can't use the unqualified <code class="literal">lang</code> property. But MQL will not allow you to use the full property name <code class="literal">/type/text/lang</code> in a reflective query. Also, a wildcard query <code class="literal">"*":null</code> in <code class="literal">any_value</code> expands only to the <code class="literal">type</code> and <code class="literal">value</code> properties. If you're interested in reflecting on text values only, you can just do this:
          </p>
          <pre class="programlisting">{
  "id":"/en/the_police",
  "/type/reflect/any_value": [{
    "type":"/type/text",
    "link":null,
    "value":null,
    "lang":null
  }]
}
</pre>
          <p>
            But if you want to query the language id of text values without restricting your reflective query to return only text values, you must do something like this:
          </p>
          <pre class="programlisting">{
  "id" : "/en/the_police",
  "/type/reflect/any_value" : [{
    "*" : null,
    "link" : {
      "master_property" : null,
      "target" : {
        "id" : null,
        "optional" : true
      }
    }
  }]
}
</pre>
          <p>
            We'll end this discussion of reflection with a more advanced query. It asks for the id and type of objects that have outgoing links objects named The Police and Sting. Two results are shown, including the important <code class="literal">/music/group_membership</code> object that specifies that Sting was a member of The Police:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">[{
  "id":null,
  "type":[],
  "first:/type/reflect/any_master": {
    "name":"Sting",
    "link":null
  },
  "second:/type/reflect/any_master": {
    "name":"The Police",
    "link":null
  }
}]
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">[{
  "id":"/guid/9202a8c04000641f8000000003924426",
  "type":["/music/group_membership"],
  "first:/type/reflect/any_master": {
    "link":"/music/group_membership/member",
    "name":"Sting"
  },
  "second:/type/reflect/any_master": {
    "link":"/music/group_membership/group",
    "name":"The Police"
  }
},{
  "id":"/user/saraw524",
  "type": [
    "/type/user",
    "/type/namespace",
    "/freebase/user_profile"
  ],
  "first:/type/reflect/any_master": {
    "link":"/freebase/user_profile/favorite_music_artists",
    "name":"Sting"
  },
  "second:/type/reflect/any_master": {
    "link":"/freebase/user_profile/favorite_music_artists",
    "name":"The Police"
  }
}]
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            A similar query could be written to find objects that link to both Arnold Schwarzenegger and Maria Shriver: it would find objects representing their marriage and their children.
          </p>
        </div>
        <div class="sect2" lang="en" xml:lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">
                  <a id="history" name="history"></a>3.7.4. History
                </h3>
              </div>
            </div>
          </div>
          <p>
            Objects in a Metaweb database live forever: once created they can never be deleted. The closest we can come to deleting an object is to remove all links from and to it. Somewhat more surprising is the fact that links live on forever in Metaweb, too. A link may be deleted or replaced with a new value, but the historical existence of that link is retained. We've already seen that we can query the creation timestamp of any object or any link. But there is another kind of history query we can express with MQL as well. The <code class="literal">valid</code> property of a link specifies whether the link is currently valid or not. The following query, for example, finds the most recently invalidated link between an object and a name. The <code class="literal">target_value</code> property returns the old name of the object, and <code class="literal">source.name</code> returns the name that has replaced it.
          </p>
          <pre class="programlisting">[{
  "type" : "/type/link",
  "valid" : false,
  "master_property" : "/type/object/name",
  "source" : {},
  "target_value" : null,
  "limit" : 1,
  "timestamp" : null,
  "sort" : "-timestamp"
}]
</pre>
          <p>
            It is important to understand that MQL link queries normally only return valid links. You can explicitly request links that are no longer valid with <code class="literal">"valid":false</code>, and you can request links that are either valid or invalid with <code class="literal">"valid":null</code> or by using a wildcard like <code class="literal">"link":{"*":null}</code>. All other link queries (with one exception involving the <code class="literal">operation</code> property that we'll learn about below) are made with an implicit <code class="literal">"valid":true</code>. As an example, consider the following query for the name of the <code class="literal">/finance/currency</code> object and the date that it was given its name:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id" : "/finance/currency",
  "name" : {
    "value" : null,
    "link" : {
      "timestamp" : null
    }
  }
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/finance/currency",
  "name" : {
    "value" : "Currency",
    "link" : {
      "timestamp" : "2007-03-25T00:33:28.0000Z"
    }
  }
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            The name of the object is "Currency" and it has been since March 25th, 2007. Now let's alter the query slightly to ask for links of any validity:
          </p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col>
                <col>
              </colgroup>
              <thead>
                <tr>
                  <th>
                    Query
                  </th>
                  <th>
                    Result
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>
                    <pre class="programlisting">{
  "id" : "/finance/currency",
  "name" : [{
    "value" : null,
    "link" : {
      "valid" : null,
      "timestamp" : null
    }
  }]
}
</pre>
                  </td>
                  <td>
                    <pre class="programlisting">{
  "id" : "/finance/currency",
  "name" : [{
    "value" : "currency",
    "link" : {
      "valid" : false,
      "timestamp" : "2006-10-22T07:34:51.0008Z"
    }
  },{
    "value" : "Currency",
    "link" : {
      "valid" : true,
      "timestamp" : "2007-03-25T00:33:28.0000Z"
    }
  }]
}
</pre>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>
            This query tells us that on October 22nd, 2006 the <code class="literal">/finance/currency</code> object was given the name "currency" (with a lowercase c), but that that name was changed to "Currency" on March 25th of the following year. Note that the name query is now written using square brackets. When querying link history, we must use square brackets even with unique properties because the property may have had more than one value over time.
          </p>
          <p>
            Metaweb makes a record of every insertion, deletion and update of a link, and the <code class="literal">operation</code> property of a link allows us to use this in queries. The possible values of this property are "insert", "delete" and "update". Links that correspond to unique properties (including the <code class="literal">name</code> property) can be inserted, deleted, or updated. Links that correspond to non-unique properties, however, are never updated: they can only be inserted and deleted.
          </p>
          <p>
            We use the <code class="literal">operation</code> property in the following query to find types that have been deleted (that is: objects that used to be linked to <code class="literal">/type/type</code>, but are no longer) and also ask when they were deleted and by whom. (Note that the <code class="literal">creator</code> property of a link can also refer to the user who deleted or updated a link as well).
          </p>
          <pre class="programlisting">[{
  "type" : "/type/link",
  "operation" : "delete",
  "master_property" : "/type/object/type",
  "source" : {},
  "target" : { "id" : "/type/type" },
  "timestamp" : null,
  "creator":null,
}]
</pre>
          <p>
            Note that this query explicitly asks for links that have been deleted. This means that it returns invalid links even though it does not include <code class="literal">"valid":null</code> or <code class="literal">"valid":false</code>. If you merely query the <code class="literal">operation</code> property with <code class="literal">"operation":null</code>, you will not get invalid links unless you also query or constrain the <code class="literal">valid</code> property. If you query the <code class="literal">operation</code> property without using the <code class="literal">valid</code> property, the results you get will only include insertions and updates, not deletions, because a link that has been deleted is, by definition, no longer valid. The <code class="literal">valid</code> property of a deleted link is actually <code class="literal">null</code>, not <code class="literal">false</code>, so writing a query for links that are invalid will only return links that have been updated, not those that have been deleted. To find deleted links, you must explicitly use <code class="literal">"operation":"delete"</code>.
          </p>
          <p>
            Here's a complex query that asks for type objects that have had their English names changed. It also asks when those changes were made, and by who. It tells us, for example, that the type <code class="literal">/location/province</code> was originally named "Province", but that <code class="literal">/user/colin</code> updated the name to "Canadian Province" in January 2007. Then <code class="literal">/user/jeff</code> updated the name to "CA Province" in August 2007 and then updated it back to "Canadian Province" in November 2007. Rather than using a top-level <code class="literal">/type/link</code> query, this query uses two different <code class="literal">link</code> directives to find both the original insertion of the name and also all subsequent updates to the name.
          </p>
          <pre class="programlisting">[{
  "type":"/type/type",
  "id":null,
  "original:name":[{
    "value":null,
    "link": {
       "operation":"insert",
       "valid":false,
       "timestamp":null,
       "creator":null
    }
  }],
  "new:name": [{
    "value":null,
    "link": {
       "operation":"update",
       "valid":null,
       "timestamp":null,
       "creator":null
    }
  }]
}]
</pre>
          <p>
            Note again that the name queries are surrounded by square brackets because historical queries must be expected to return multiple results. This query does not ask about name deletions: it assumes that names are changed by updates rather than deletions and re-insertions. We can write a simpler and more general query to ask about the complete name history of type objects:
          </p>
          <pre class="programlisting">[{
  "type" : "/type/type",
  "id" : null,
  "name" : [{
    "value" : null,
    "sort" : "link.timestamp",
    "link" : {
      "valid" : null,
      "operation" : null,
      "creator" : null,
      "timestamp" : null
    }
  }]
}]
</pre>
          <p>
            The problem with this query is that it matches any type with a name, even types that have never had the name changed. We can fix this by requiring that the type object have at least one currently invalid name link:
          </p>
          <pre class="programlisting">[{
  "type" : "/type/type",
  "id" : null,
  "number_of_invalid:name" : [{
    "return" : "count",
    "link" : { "valid" : false  }
  }],
  "name" : [{
    "value" : null,
    "sort" : "link.timestamp",
    "link" : {
      "valid" : null,
      "operation" : null,
      "creator" : null,
      "timestamp" : null
    }
  }]
}]
</pre>
        </div>
      </div>
      <div class="footnotes">
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2948012" id="ftn.id2948012" name="ftn.id2948012">7</a>]</sup> MQL is pronounced "mickle". It rhymes with "pickle", not "sequel".
          </p>
        </div>
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2948079" id="ftn.id2948079" name="ftn.id2948079">8</a>]</sup> You should read this section even if you already know JavaScript. JSON is only a subset of JavaScript, and its syntax is stricter than JavaScript syntax.
          </p>
        </div>
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2948108" id="ftn.id2948108" name="ftn.id2948108">9</a>]</sup> The JSON syntax diagrams that appear below are also from the JSON website, where they have been placed in the public domain.
          </p>
        </div>
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2948241" id="ftn.id2948241" name="ftn.id2948241">10</a>]</sup> JSON itself supports 32-bit, 16-bit and 8-bit encodings of Unicode text. Metaweb, however, requires the 8-bit UTF-8 encoding.
          </p>
        </div>
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2949293" id="ftn.id2949293" name="ftn.id2949293">11</a>]</sup> Objects may actually have more than one name, but may only have one name in any given language. For this reason, simple name queries only return one value. We'll see more about this later in the chapter.
          </p>
        </div>
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2951364" id="ftn.id2951364" name="ftn.id2951364">12</a>]</sup> September, 2008
          </p>
        </div>
        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2954555" id="ftn.id2954555" name="ftn.id2954555">13</a>]</sup> Metaweb's ordered collections are sometimes described as lists, but this term is inaccurate because lists are allowed to have duplicate elements. Metaweb's ordered collections are still fundamentally sets, and duplicates are not allowed.
          </p>
        </div>

        <div class="footnote">
          <p>
            <sup>[<a class="para" href="http://mql.freebaseapps.com/ch03#id2955740" id="ftn.id2955740" name="ftn.id2955740">14</a>]</sup> If you've done programming with languages like Perl or Ruby, this syntax should look familiar. If you've worked with SQL queries for relational databases, <code class="literal">~=</code> is like the SQL <code class="literal">%</code> operator. Otherwise, think of "~=" as meaning "approximately equal" or "like".
          </p>
        </div>
      </div>
    </div>
    
  
</div></body></html>